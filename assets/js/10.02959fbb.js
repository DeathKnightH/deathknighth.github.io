(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{364:function(t,a,r){t.exports=r.p+"assets/img/memento_innerclass.drawio.a909f1d5.png"},365:function(t,a,r){t.exports=r.p+"assets/img/memento_interface.drawio.685d9bf5.png"},442:function(t,a,r){"use strict";r.r(a);var e=r(44),_=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"备忘录模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#备忘录模式"}},[t._v("#")]),t._v(" 备忘录模式")]),t._v(" "),e("h2",{attrs:{id:"_1-概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念"}},[t._v("#")]),t._v(" 1.概念")]),t._v(" "),e("p",[t._v("是一种行为设计模式，又称 Memento/快照/Snapshot。")]),t._v(" "),e("h2",{attrs:{id:"_2-意图"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-意图"}},[t._v("#")]),t._v(" 2.意图")]),t._v(" "),e("p",[t._v("在不暴露内部实现的前提下，保存和恢复对象在操作之前的状态。")]),t._v(" "),e("h2",{attrs:{id:"_3-类图示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-类图示例"}},[t._v("#")]),t._v(" 3.类图示例")]),t._v(" "),e("p",[t._v("根据语言特性可以分为两种实现：")]),t._v(" "),e("h3",{attrs:{id:"_3-1-内部类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-内部类"}},[t._v("#")]),t._v(" 3.1 内部类")]),t._v(" "),e("p",[e("img",{attrs:{src:r(364),alt:"innerclass"}})]),t._v(" "),e("p",[t._v("其中 Memento 是 Originator 的内部类，且内部方法和成员全部为私有：")]),t._v(" "),e("ul",[e("li",[t._v("Caretaker 只能存储  Memento 对象，不能访问 Memento 的成员和方法。")]),t._v(" "),e("li",[t._v("在需要恢复状态时，将 Memento 传入 Originator 的 recover 方法，这样因为是自己的内部类， Originator 可以访问 Memento 内部的成员和方法，重新设置状态。")])]),t._v(" "),e("h3",{attrs:{id:"_3-2-中间接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-中间接口"}},[t._v("#")]),t._v(" 3.2 中间接口")]),t._v(" "),e("p",[e("img",{attrs:{src:r(365),alt:"interface"}})]),t._v(" "),e("p",[t._v("其中 Caretaker 只和 Memento 交互，恢复状态时调用 Memento 自己的 recover 方法，通过内部对应 ConcreteOriginator 的设置状态的方法恢复对应状态。")]),t._v(" "),e("h2",{attrs:{id:"_4-适用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-适用场景"}},[t._v("#")]),t._v(" 4.适用场景")]),t._v(" "),e("h3",{attrs:{id:"_4-1-业务场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-业务场景"}},[t._v("#")]),t._v(" 4.1 业务场景")]),t._v(" "),e("ul",[e("li",[t._v("任何需要记录当前操作步骤并可以撤销操作的业务逻辑都可以使用备忘录。")])]),t._v(" "),e("h3",{attrs:{id:"_4-2-开源实例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-开源实例"}},[t._v("#")]),t._v(" 4.2 开源实例")]),t._v(" "),e("p",[t._v("JDK 中所有 java.io.Serializable 接口的实现都可以用作备忘录。")]),t._v(" "),e("h2",{attrs:{id:"_5-实现细节与技巧"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-实现细节与技巧"}},[t._v("#")]),t._v(" 5.实现细节与技巧")]),t._v(" "),e("ul",[e("li",[t._v("关键点是封装 Originator 类的内部实现，不让其他类获取/查看其内部的成员变量和状态，这一点最好通过内部类配合 private 方法实现。")]),t._v(" "),e("li",[t._v("另一个关键点是 Memento 的状态不可变，所以经常是 final 修饰的，内部状态是也是 final，只有创建时通过构造函数才能初始化状态。")])]),t._v(" "),e("h2",{attrs:{id:"_6-优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-优缺点"}},[t._v("#")]),t._v(" 6.优缺点")]),t._v(" "),e("p",[t._v("优点：")]),t._v(" "),e("ul",[e("li",[t._v("可以在不破坏 Originator 封装性的前提下管理它的快照对象。")]),t._v(" "),e("li",[t._v("将历史记录从 Originator 独立出来，减少 Originator 对象的复杂性和大小。")])]),t._v(" "),e("p",[t._v("缺点：")]),t._v(" "),e("ul",[e("li",[t._v("很多动态语言都无法确保 Memento 中的状态不改变，比如 JavaScript/Python/PHP 等。")]),t._v(" "),e("li",[t._v("如果状态对象很大，或者 Memento 创建过多，可能占用大量的内存。")])]),t._v(" "),e("h2",{attrs:{id:"_7-与其他设计模式的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-与其他设计模式的关系"}},[t._v("#")]),t._v(" 7.与其他设计模式的关系")])])}),[],!1,null,null,null);a.default=_.exports}}]);