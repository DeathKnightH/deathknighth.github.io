(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{393:function(a,t,l){"use strict";l.r(t);var _=l(44),s=Object(_.a)({},(function(){var a=this,t=a.$createElement,l=a._self._c||t;return l("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[l("h1",{attrs:{id:"thread-基础"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#thread-基础"}},[a._v("#")]),a._v(" Thread 基础")]),a._v(" "),l("h2",{attrs:{id:"_1-线程使用方式-构造一个线程有几种方式"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_1-线程使用方式-构造一个线程有几种方式"}},[a._v("#")]),a._v(" 1. 线程使用方式/构造一个线程有几种方式")]),a._v(" "),l("ul",[l("li",[a._v("继承 Thread 类\n"),l("ul",[l("li",[a._v("使用方便，自身就是一个线程，可以直接使用。")]),a._v(" "),l("li",[a._v("因为 java 不支持多继承，所有这样无法继承其他类。")])])]),a._v(" "),l("li",[a._v("实现 Runnable 接口\n"),l("ul",[l("li",[a._v("构造灵活。")]),a._v(" "),l("li",[a._v("没有返回值。")]),a._v(" "),l("li",[a._v("不是真正意义上的一个线程，最终使用时还是通过 Thread 类来调用。")])])]),a._v(" "),l("li",[a._v("实现 Callable 接口\n"),l("ul",[l("li",[a._v("构造灵活。")]),a._v(" "),l("li",[a._v("有返回值。")]),a._v(" "),l("li",[a._v("不是真正意义上的一个线程，最终使用时还是通过 Thread 类来调用。")])])])]),a._v(" "),l("h2",{attrs:{id:"_2-守护线程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2-守护线程"}},[a._v("#")]),a._v(" 2. 守护线程")]),a._v(" "),l("p",[a._v("JVM 中线程分为两类")]),a._v(" "),l("ul",[l("li",[a._v("普通线程")]),a._v(" "),l("li",[a._v("守护线程")])]),a._v(" "),l("p",[a._v("守护线程属于非必要线程，相当于后台无关紧要的辅助程序，因此当所有非守护线程都结束时，守护线程都会直接被丢弃（kill）。")]),a._v(" "),l("p",[a._v("调用 Thread 对象的")]),a._v(" "),l("div",{staticClass:"language- line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("setDaemon(true)\n")])]),a._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[a._v("1")]),l("br")])]),l("p",[a._v("方法可以将一个 Thread 设置为守护线程，但是因为守护线程的推出非常直接（不会执行finally块，也不会执行回卷栈，而是直接退出），如果守护线程中有类似I/O这样的有关对外操作时会很危险，所以要谨慎使用守护线程，尽量在实现一些不重要的辅助功能时使用守护线程，例如清理无效缓存等。")]),a._v(" "),l("p",[a._v("一个 JVM 在启动时创建的线程中，除了主线程（main 方法所在的线程），其他都是守护线程（垃圾回收线程等）。")]),a._v(" "),l("h2",{attrs:{id:"_3-线程间协作"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_3-线程间协作"}},[a._v("#")]),a._v(" 3. 线程间协作")]),a._v(" "),l("p",[a._v("当一个线程的运行依赖于其他线程的结果，此时简单的做法可以利用线程间协作的写法。")]),a._v(" "),l("h3",{attrs:{id:"join"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#join"}},[a._v("#")]),a._v(" join()")]),a._v(" "),l("p",[a._v("假设有两个线程 a 和 b；")]),a._v(" "),l("p",[a._v("在 a 中调用 b.join() 会使 a 线程 "),l("strong",[a._v("挂起")]),a._v(" ，等到 b 线程执行完毕才会唤醒 a 线程。")]),a._v(" "),l("h3",{attrs:{id:"wait-notify-notifyall"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#wait-notify-notifyall"}},[a._v("#")]),a._v(" wait()/notify()/notifyAll()")]),a._v(" "),l("h3",{attrs:{id:"await-signal-signalall"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#await-signal-signalall"}},[a._v("#")]),a._v(" await()/signal()/signalAll()")])])}),[],!1,null,null,null);t.default=s.exports}}]);