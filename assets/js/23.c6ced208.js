(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{380:function(t,_,v){"use strict";v.r(_);var r=v(44),a=Object(r.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"计数排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计数排序"}},[t._v("#")]),t._v(" 计数排序")]),t._v(" "),v("p",[t._v("计数排序（Counting Sort）是一种基于"),v("code",[t._v("非比较")]),t._v("的具有线性时间复杂度的排序算法。")]),t._v(" "),v("p",[t._v("计数排序高效的前提是元素的值域（基数）较小。")]),t._v(" "),v("h2",{attrs:{id:"_1-工作原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-工作原理"}},[t._v("#")]),t._v(" 1. 工作原理")]),t._v(" "),v("p",[t._v("使用一个额外的数组 "),v("code",[t._v("C[i]")]),t._v("，其中第 i 个元素是待排序序列中值等于 i 的个数。")]),t._v(" "),v("p",[t._v("工作流程大致分为以下3步：")]),t._v(" "),v("ul",[v("li",[t._v("遍历序列，计数每个元素出现的次数，放入数组 "),v("code",[t._v("C[i]")])]),t._v(" "),v("li",[t._v("遍历数组 "),v("code",[t._v("C[i]")]),t._v("，计算前缀和。")]),t._v(" "),v("li",[t._v("根据前缀和，遍历原序列重新构造一个数组")])]),t._v(" "),v("h2",{attrs:{id:"_2-性质"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-性质"}},[t._v("#")]),t._v(" 2. 性质")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("性质")]),t._v(" "),v("th"),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("稳定性")]),t._v(" "),v("td",[t._v("稳定")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("最坏时间复杂度")]),t._v(" "),v("td",[t._v("O(n + w)")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("最好时间复杂度")]),t._v(" "),v("td",[t._v("O(n + w)")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("平均时间复杂度")]),t._v(" "),v("td",[t._v("O(n + w)")]),t._v(" "),v("td",[t._v("w是值域大小，各需遍历原序列和值域数组有限次数")])]),t._v(" "),v("tr",[v("td",[t._v("空间复杂度")]),t._v(" "),v("td",[t._v("O(n + w)")]),t._v(" "),v("td",[t._v("需要一个和原序列大小相同的新序列，以及一个满足值域大小（w）的数组用于计数")])])])])])}),[],!1,null,null,null);_.default=a.exports}}]);