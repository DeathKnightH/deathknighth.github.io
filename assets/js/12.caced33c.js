(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{358:function(t,a,r){t.exports=r.p+"assets/img/mediator.drawio.7c095e7e.png"},442:function(t,a,r){"use strict";r.r(a);var e=r(44),_=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"中介者模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#中介者模式"}},[t._v("#")]),t._v(" 中介者模式")]),t._v(" "),e("h2",{attrs:{id:"_1-概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念"}},[t._v("#")]),t._v(" 1.概念")]),t._v(" "),e("p",[t._v("是一种行为设计模式，又称 Mediator/控制器/Controller 模式。")]),t._v(" "),e("h2",{attrs:{id:"_2-意图"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-意图"}},[t._v("#")]),t._v(" 2.意图")]),t._v(" "),e("p",[t._v("将各个对象互相之间的沟通/控制抽象出来集中到一个 Mediator 中处理，解耦各个业务对象。")]),t._v(" "),e("h2",{attrs:{id:"_3-类图示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-类图示例"}},[t._v("#")]),t._v(" 3.类图示例")]),t._v(" "),e("p",[e("img",{attrs:{src:r(358),alt:"mediator"}})]),t._v(" "),e("p",[t._v("如图所示：")]),t._v(" "),e("ul",[e("li",[t._v("初始化时由 Client 创建各个 Component，传入 ConcreteMediator 构造函数来构造 ConcreteMediator。")]),t._v(" "),e("li",[t._v("使用时由 Client 或者 Component 调用 ConcreteMediator 的 notify 方法，传入触发者和触发事件，让 ConcreteMediator 调用目标 Component 的具体方法。")])]),t._v(" "),e("h2",{attrs:{id:"_4-适用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-适用场景"}},[t._v("#")]),t._v(" 4.适用场景")]),t._v(" "),e("h3",{attrs:{id:"_4-1-业务场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-业务场景"}},[t._v("#")]),t._v(" 4.1 业务场景")]),t._v(" "),e("ul",[e("li",[t._v("一组相关对象互相之间会产生交互控制时，可以考虑中介者模式：\n"),e("ul",[e("li",[t._v("比如传统 web 开发中 service 层的业务对象是可以互相调用的，如果直接对外提供接口，可想而知行为逻辑会很复杂。")]),t._v(" "),e("li",[t._v("这时考虑为每个特定场景添加一个 Controller，由 Controller 对外提供接口，对内协调各 service 的互相调用。")])])])]),t._v(" "),e("h3",{attrs:{id:"_4-2-开源实例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-开源实例"}},[t._v("#")]),t._v(" 4.2 开源实例")]),t._v(" "),e("ul",[e("li",[t._v("MVC 模式中的 Controller 就是中介者。")]),t._v(" "),e("li",[t._v("各种 GUI 框架中也常见中介者模式来协调同一个操作界面下各组件的控制。")])]),t._v(" "),e("h2",{attrs:{id:"_5-实现细节与技巧"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-实现细节与技巧"}},[t._v("#")]),t._v(" 5.实现细节与技巧")]),t._v(" "),e("ul",[e("li",[t._v("中介者的关键是 Mediator 接口的方法，通常用一个方法（发送者和触发事件作为参数）就能触发所有成员的功能。")]),t._v(" "),e("li",[t._v("Component 中最好包含 Mediator 成员，方便在执行功能时自行通过 Mediator 触发其他 Component 的方法。")])]),t._v(" "),e("h2",{attrs:{id:"_6-优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-优缺点"}},[t._v("#")]),t._v(" 6.优缺点")]),t._v(" "),e("p",[t._v("优点：")]),t._v(" "),e("ul",[e("li",[t._v("符合单一职责原则，将组件之间的调用抽象到一处。")]),t._v(" "),e("li",[t._v("符合开闭原则，ConcreteMediator 对修改关闭，可以新增新的 ConcreteMediator 完成新的控制操作。")]),t._v(" "),e("li",[t._v("可以减少 Component 间的耦合。")]),t._v(" "),e("li",[t._v("可以复用 Component。")])]),t._v(" "),e("p",[t._v("缺点：")]),t._v(" "),e("ul",[e("li",[t._v("如果抽象过于集中，Mediator 可能演变为上帝对象。")])]),t._v(" "),e("h2",{attrs:{id:"_7-与其他设计模式的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-与其他设计模式的关系"}},[t._v("#")]),t._v(" 7.与其他设计模式的关系")])])}),[],!1,null,null,null);a.default=_.exports}}]);