(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{369:function(t,a,e){"use strict";e.r(a);var s=e(44),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"aqs-abstract-queued-synchronizer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aqs-abstract-queued-synchronizer"}},[t._v("#")]),t._v(" AQS(Abstract Queued Synchronizer)")]),t._v(" "),e("h2",{attrs:{id:"_1-核心思想"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-核心思想"}},[t._v("#")]),t._v(" 1. 核心思想")]),t._v(" "),e("ul",[e("li",[t._v("如果被请求的共享资源空闲")])]),t._v(" "),e("p",[t._v("将当前请求资源的线程设置为当前工作线程，并将共享资源加锁。")]),t._v(" "),e("ul",[e("li",[t._v("如果被请求的共享资源被占用")])]),t._v(" "),e("p",[t._v("将暂时获取不到锁的线程放入队列中等待解锁时唤醒，这个队列在 AQS 中是一个 CLH 队列。\nAQS 将每个请求资源的线程封装成一个 Node 放入 CLH 队列，实现锁分配。")]),t._v(" "),e("h2",{attrs:{id:"_2-实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现原理"}},[t._v("#")]),t._v(" 2. 实现原理")]),t._v(" "),e("h3",{attrs:{id:"_2-1-同步状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-同步状态"}},[t._v("#")]),t._v(" 2.1 同步状态")]),t._v(" "),e("p",[t._v("AQS 内部使用一个 volatile 修饰的 int 变量表示同步状态：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("private volatile int state;\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("有3个方法可以直接操作 state，其他方法都是通过这3个方法间接操作 state：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 获取当前 state 值，相当于 volatile 读\nprotected final int getState() {\n  return state;\n}\n\n// 设置 state 值，相当于 volatile 写\nprotected final void setState(int newState) {\n  state = newState;\n}\n\n// 使用 CAS 根据 expect 设置 state 的值为 update，相当于原子地 volatile 读+写\nprotected final boolean compareAndSetState(int expect, int update) {\n  return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br")])]),e("h3",{attrs:{id:"_2-2-资源共享方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-资源共享方式"}},[t._v("#")]),t._v(" 2.2 资源共享方式")]),t._v(" "),e("p",[t._v("分为两种：")]),t._v(" "),e("ul",[e("li",[t._v("独占\n同一时间只有一个线程能够使用共享资源，独占锁根据线程竞争方式还可以分为：\n"),e("ul",[e("li",[t._v("公平锁：根据线程在等待队列中的顺序，先到先得。")]),t._v(" "),e("li",[t._v("非公平锁：所有等待线程一起竞争，谁竞争到谁得。")])])]),t._v(" "),e("li",[t._v("共享")])]),t._v(" "),e("p",[t._v("同一时间可以有多个线程访问共享资源，例如 CountDownLatch、Semaphore、CyclicBarrier、ReadWriteLock。\n其实 ReentrantReadWriteLock 是两种混合的，读和读之间是共享的，写和其他操作之间是独占的。")]),t._v(" "),e("h3",{attrs:{id:"_2-3-sync-queue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-sync-queue"}},[t._v("#")]),t._v(" 2.3 Sync queue")]),t._v(" "),e("p",[t._v("AQS 内部的锁队列是一个 CLH，虚拟双向队列，其实存储的不是一个队列整体，而是队列头结点和尾结点，队列关系由 Node 类来维护。\n"),e("img",{attrs:{src:"https://user-images.githubusercontent.com/19852729/124567435-95765700-de76-11eb-836c-970013d17d44.png",alt:"image"}})]),t._v(" "),e("p",[t._v("Node 内部除了封装了等待线程、前驱、后驱结点，还有 waitStatus 和 nextWaiter 结点指针。")]),t._v(" "),e("ul",[e("li",[t._v("waitStatus 表示了当前 Node 的状态，只有以下5种值：\n"),e("ul",[e("li",[e("p",[t._v("SIGNAL(-1)")]),t._v(" "),e("p",[t._v("表示后继结点需要被唤醒。当前结点需要 unpark")])]),t._v(" "),e("li",[e("p",[t._v("CANCELLED(1)")]),t._v(" "),e("p",[t._v("结点中的线程已超时或者中断，表示为这个状态的结点不会再改变状态。")])]),t._v(" "),e("li",[e("p",[t._v("CONDITION(-2)")]),t._v(" "),e("p",[t._v("这个状态表示这个 Node 是在一个 Condition 队列中。当有其他线程调用了 Condition 的 signal() 方法后，会从 Condition 队列转移到 Sync 队列。")])]),t._v(" "),e("li",[e("p",[t._v("PROPAGATE(-3)")]),t._v(" "),e("p",[t._v("在 doReleaseShared 中保证 releaseShared 会被传递给其他结点，通常只有 head node 会设置这个状态。")])]),t._v(" "),e("li",[e("p",[t._v("0")]),t._v(" "),e("p",[t._v("表示等待状态，新 Node 进入 Sync 队列时的默认状态。\n可以看出 waitStatus <= 0 时处于正常等待状态，waitStatus > 0 时处于取消状态。")])])])]),t._v(" "),e("li",[t._v("nextWaiter 主要用于有 Condition 存在时，使用这个 nextWaiter 指针组成一个单链表形式的 Condition 队列。")])]),t._v(" "),e("h3",{attrs:{id:"_2-4-conditionobject"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-conditionobject"}},[t._v("#")]),t._v(" 2.4 ConditionObject")]),t._v(" "),e("p",[t._v("ConditionObject 实现了 Condition 接口，主要实现了两个类型的操作，await 操作用于等待 signal，signal 操作用于唤醒等待的线程。\n类的内部维护了一个由 Node 组成的 Condition 队列，说是队列其实是一个记录了头结点和尾结点的单链表。\nCondition 队列中的 Node 的 nextWaiter 指向下一个 Node， 状态为 CONDITION(-2) 或者 CANCELLED(1)。")]),t._v(" "),e("h3",{attrs:{id:"_2-5-核心方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-核心方法"}},[t._v("#")]),t._v(" 2.5 核心方法")]),t._v(" "),e("h4",{attrs:{id:"_2-5-1-独占方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-1-独占方式"}},[t._v("#")]),t._v(" 2.5.1 独占方式")]),t._v(" "),e("ul",[e("li",[t._v("acquire")])]),t._v(" "),e("p",[t._v("以独占模式获取资源，忽略中断。")]),t._v(" "),e("ul",[e("li",[t._v("release")])]),t._v(" "),e("p",[t._v("以独占模式释放资源。")]),t._v(" "),e("h4",{attrs:{id:"_2-5-2-共享方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-2-共享方式"}},[t._v("#")]),t._v(" 2.5.2 共享方式")]),t._v(" "),e("ul",[e("li",[t._v("acquireShared")])]),t._v(" "),e("p",[t._v("以共享模式获取资源。")]),t._v(" "),e("ul",[e("li",[t._v("releaseShared")])]),t._v(" "),e("p",[t._v("以共享模式释放资源。")]),t._v(" "),e("h2",{attrs:{id:"_3-实际应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-实际应用"}},[t._v("#")]),t._v(" 3. 实际应用")]),t._v(" "),e("p",[t._v("java.util.concurrent 包下提供了很多基于 AQS 实现的同步器，日常开发使用这些同步器就够用")]),t._v(" "),e("h3",{attrs:{id:"_3-1-reentrantlock"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-reentrantlock"}},[t._v("#")]),t._v(" 3.1 ReentrantLock")]),t._v(" "),e("h3",{attrs:{id:"_3-2-countdownlatch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-countdownlatch"}},[t._v("#")]),t._v(" 3.2 CountDownLatch")]),t._v(" "),e("h3",{attrs:{id:"_3-3-semaphore"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-semaphore"}},[t._v("#")]),t._v(" 3.3 Semaphore")]),t._v(" "),e("h3",{attrs:{id:"_3-4-cyclicbarrier"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-cyclicbarrier"}},[t._v("#")]),t._v(" 3.4 CyclicBarrier")]),t._v(" "),e("h2",{attrs:{id:"_4-自定义同步器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-自定义同步器"}},[t._v("#")]),t._v(" 4. 自定义同步器")]),t._v(" "),e("p",[t._v("AQS 采用"),e("strong",[t._v("模板方法")]),t._v("模式设计，acquire()/release() 等 public 方法都是 final 的，对子类开放了一些 protected 方法，供子类修改实现。")]),t._v(" "),e("ul",[e("li",[t._v("tryAcquire(int)\n独占方式，尝试获取资源，成功返回 true，失败返回 false。")]),t._v(" "),e("li",[t._v("tryRelease(int)\n独占方式，尝试释放资源，成功返回 true，失败返回 false。")]),t._v(" "),e("li",[t._v("tryAcquireShared(int)\n共享方式，尝试获取资源，失败返回负数，成功但没有剩余可用资源返回 0，成功且仍有剩余可用资源返回正数。")]),t._v(" "),e("li",[t._v("tryReleaseShared(int)\n共享方式，尝试释放资源，成功返回 true，失败返回 false。")]),t._v(" "),e("li",[t._v("isHeldExclusively()\n判断当前线程是否正在独占资源。用到 Condition 时才会重写这个方法。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);