(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{502:function(a,s,t){"use strict";t.r(s);var e=t(44),r=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"函数式编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程"}},[a._v("#")]),a._v(" 函数式编程")]),a._v(" "),t("h2",{attrs:{id:"_1-概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念"}},[a._v("#")]),a._v(" 1.概念")]),a._v(" "),t("p",[a._v("面向对象编程是对数据的抽象；函数式编程是对行为的抽象。")]),a._v(" "),t("p",[a._v("语法上增加对 lambda 表达式的支持，核心类库中增加 Stream 相关类，给集合类添加了相关 API（比如stream()方法），同时新增了一些内置的函数接口（比如 java.util.Comparator）。")]),a._v(" "),t("h2",{attrs:{id:"_2-lambda-表达式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-lambda-表达式"}},[a._v("#")]),a._v(" 2.lambda 表达式")]),a._v(" "),t("p",[a._v("又称闭包或者匿名函数，是。")]),a._v(" "),t("h3",{attrs:{id:"_2-1-适用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-适用场景"}},[a._v("#")]),a._v(" 2.1 适用场景")]),a._v(" "),t("p",[a._v("函数式接口调用可以使用 lambda 表达式替换，函数式接口包括：")]),a._v(" "),t("ul",[t("li",[a._v("只有一个抽象方法的接口")]),a._v(" "),t("li",[a._v("使用了 @FunctionalInterface 注解的接口，其实就是只有一个抽象方法的接口，加了这个注解的接口如果有一个以上抽象方法会有语法检查错误。")])]),a._v(" "),t("h3",{attrs:{id:"_2-2-作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-作用域"}},[a._v("#")]),a._v(" 2.2 作用域")]),a._v(" "),t("p",[a._v("在 lambda 表达式中可以使用：")]),a._v(" "),t("ul",[t("li",[a._v("实例成员")]),a._v(" "),t("li",[a._v("静态成员")]),a._v(" "),t("li",[a._v("局部变量：不用显式 final，但是需要隐式 final，即可以不加 final 关键字，但是局部变量必须不能在 lambda 表达式后的代码中被修改。")])]),a._v(" "),t("p",[a._v("不能使用：")]),a._v(" "),t("ul",[t("li",[a._v("接口的 default 方法")])]),a._v(" "),t("p",[a._v("需要注意如果 lambda 表达式使用了局部变量，那么表达式内部不能对局部变量进行修改，否则会报Compile time error。")]),a._v(" "),t("h3",{attrs:{id:"_2-3-使用-lambda"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-使用-lambda"}},[a._v("#")]),a._v(" 2.3 使用 lambda")]),a._v(" "),t("p",[a._v("以 Comparator 接口为例。")]),a._v(" "),t("p",[a._v("通用写法：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Arrays.sort(array, (a, b) ->{\n  if(a.size() != b.size()){\n    return a.size() - b.size();\n  }\n  // other compare\n  ...\n});\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br")])]),t("p",[a._v("当实现的方法体只有一行时还能去掉 return 简化成：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Arrays.sort(array, (a, b) -> a.value() - b.value());\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("当实现的方法体只有另一个参数列表一样的方法，可以使用方法引用进一步简化：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 打印每一个元素\nlist.stream().forEach(System.out::println);\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("h3",{attrs:{id:"_2-4-lambda-表达式和匿名内部类的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-lambda-表达式和匿名内部类的区别"}},[a._v("#")]),a._v(" 2.4 lambda 表达式和匿名内部类的区别")]),a._v(" "),t("p",[a._v("编译区别：")]),a._v(" "),t("ul",[t("li",[a._v("匿名内部类会编译为一个独立的 class")]),a._v(" "),t("li",[a._v("lambda 表达式会编译为类的一个 private 方法")])]),a._v(" "),t("p",[a._v("使用局部变量的区别：")]),a._v(" "),t("ul",[t("li",[a._v("匿名内部类使用的局部变量必须是 final 修饰的")]),a._v(" "),t("li",[a._v("lambda 表达式使用的局部变量可以不用 final 修饰，但是必须保证在表达式后不对变量进行修改")])]),a._v(" "),t("h2",{attrs:{id:"_3-stream-编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-stream-编程"}},[a._v("#")]),a._v(" 3. Stream 编程")]),a._v(" "),t("p",[a._v("Java 中的 Stream 操作分为两种：")]),a._v(" "),t("ul",[t("li",[a._v("Intermediate Operations 又称中间操作/惰性求值，不会产生新的集合，包括 "),t("code",[a._v("map")]),a._v(","),t("code",[a._v("filter")]),a._v(","),t("code",[a._v("sorted")]),a._v("等")]),a._v(" "),t("li",[a._v("Terminal Operations 又称最终操作/及早求值，会产生新的集合，包括 "),t("code",[a._v("collect")]),a._v(","),t("code",[a._v("forEach")]),a._v(","),t("code",[a._v("reduce")]),a._v("等")])])])}),[],!1,null,null,null);s.default=r.exports}}]);