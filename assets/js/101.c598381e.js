(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{489:function(o,r,i){"use strict";i.r(r);var t=i(44),v=Object(t.a)({},(function(){var o=this,r=o.$createElement,i=o._self._c||r;return i("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[i("h1",{attrs:{id:"fork-join-框架"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#fork-join-框架"}},[o._v("#")]),o._v(" Fork/Join 框架")]),o._v(" "),i("h2",{attrs:{id:"_1-作用"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-作用"}},[o._v("#")]),o._v(" 1.作用")]),o._v(" "),i("p",[o._v("并行分治，将大任务分为小任务并行执行。")]),o._v(" "),i("p",[o._v("主要包含 3 个部分：")]),o._v(" "),i("ul",[i("li",[o._v("ForkJoinTask 任务对象，包含以下 3 种抽象，一般通过继承实现这 3 种抽象来定义具体的 Fork 任务：\n"),i("ul",[i("li",[o._v("RecursiveTask 可递归执行的 ForkJoin 任务，有返回值")]),o._v(" "),i("li",[o._v("RecursiveAction  无返回值的 RecursiveTask")]),o._v(" "),i("li",[o._v("CountedCompleter  任务执行完成后可以触发一个自定义的钩子函数")])])]),o._v(" "),i("li",[o._v("ForkJoinWorkerThread 执行线程")]),o._v(" "),i("li",[o._v("ForkJoinPool  线程池")])]),o._v(" "),i("h2",{attrs:{id:"_2-原理和流程"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-原理和流程"}},[o._v("#")]),o._v(" 2.原理和流程")]),o._v(" "),i("ul",[i("li",[o._v("分治")]),o._v(" "),i("li",[o._v("工作窃取：工作线程之间可以取对方未完成但已提交的任务来执行。\n"),i("ul",[i("li",[o._v("ForkJoinPool 中的每个 ForkJoinWorkerThread 都有一个工作队列")]),o._v(" "),i("li",[o._v("这些工作队列用数组保存 "),i("code",[o._v("WorkQueue[]")]),o._v("，偶数下标的工作队列用来保存外部提交的任务，不属于任何 ForkJoinWorkerThread")]),o._v(" "),i("li",[o._v("每个工作队列是一个双端队列，同时支持 FIFO 和 LIFO")]),o._v(" "),i("li",[o._v('ForkJoinWorkerThread 可以对自己的工作队列 push 和 pop，可以对别的工作队列 poll "窃取"任务')]),o._v(" "),i("li",[o._v("调用 fork 会把划分的子任务 push 到自己的工作队列，当自己的工作队列为空（任务已执行完），就可以调用其他工作队列的 poll 窃取任务来执行")])])])]),o._v(" "),i("p",[o._v("整体流程如下图\n"),i("img",{attrs:{src:"",alt:"fork/join flow"}})]),o._v(" "),i("h2",{attrs:{id:"_3-使用注意事项"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用注意事项"}},[o._v("#")]),o._v(" 3.使用注意事项")]),o._v(" "),i("ul",[i("li",[o._v("注意 fork()/compute()/join() 方法的调用顺序。\n"),i("ul",[i("li",[o._v("因为 join() 会挂起当前线程，所以要在所有 fork() 调用完之后再调用 join()。")]),o._v(" "),i("li",[o._v("调用 compute() 会使用当前工作线程直接执行任务，所以调用 compute() 也要在其他任务 fork() 之后，但也要在 join() 之前。")])])]),o._v(" "),i("li",[o._v("fork 的任务粒度需要实际测试绝定，通常情况下 1000~10000 个纯计算步骤放一个子任务比较好。")]),o._v(" "),i("li",[o._v("如果每个 task 只是简单分为有限数量个子任务，可以用 compute() 执行一个子任务，比 fork() 加入队列再从队列中取出执行要快。嫌麻烦可以直接使用 java.util.concurrent.ForkJoinTask#invokeAll(java.util.concurrent.ForkJoinTask<?>...) 方法就行，，")])])])}),[],!1,null,null,null);r.default=v.exports}}]);