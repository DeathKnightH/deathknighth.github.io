(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{453:function(a,r,s){"use strict";s.r(r);var t=s(44),e=Object(t.a)({},(function(){var a=this,r=a.$createElement,s=a._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"locksupport"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#locksupport"}},[a._v("#")]),a._v(" LockSupport")]),a._v(" "),s("p",[s("code",[a._v("LockSupport")]),a._v(" 用来创建锁和其他同步类的基本"),s("strong",[a._v("线程阻塞原语")]),a._v("。")]),a._v(" "),s("p",[a._v("具体而言，调用 "),s("code",[a._v("LockSupport.park")]),a._v(" 方法会阻塞当前线程。调用 "),s("code",[a._v("LockSupport.unpark")]),a._v(" 并传入阻塞线程作为参数，可以唤醒阻塞的线程。")]),a._v(" "),s("h2",{attrs:{id:"_1-实现细节分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-实现细节分析"}},[a._v("#")]),a._v(" 1. 实现细节分析")]),a._v(" "),s("h3",{attrs:{id:"_1-1-静态属性和构造函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-静态属性和构造函数"}},[a._v("#")]),a._v(" 1.1 静态属性和构造函数")]),a._v(" "),s("p",[s("code",[a._v("LockSupport")]),a._v(" 内部存储了 "),s("code",[a._v("Thread")]),a._v(" 类中几个关键属性的偏移地址和一个 Unsafe 类引用:")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("  private static final sun.misc.Unsafe UNSAFE;  // Unsafe 类引用\n  private static final long parkBlockerOffset;  // Thread 类中 parkBlocker 字段的偏移地址\n  private static final long SEED;               // Thread 类中 threadLocalRandomSeed 字段的偏移地址\n  private static final long PROBE;              // Thread 类中 threadLocalRandomProbe 字段的偏移地址\n  private static final long SECONDARY;          // Thread 类中 threadLocalRandomSecondarySeed 字段的偏移地址\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("p",[a._v("构造函数为 "),s("code",[a._v("private")]),a._v(" 修饰，且内部没有调用。\n对外开放的方法均为 "),s("code",[a._v("static")]),a._v(" 方法，一般使用时不会创建 "),s("code",[a._v("LockSupport")]),a._v(" 对象，直接通过类名使用 static 方法。")]),a._v(" "),s("h3",{attrs:{id:"_1-2-park"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-park"}},[a._v("#")]),a._v(" 1.2 park")]),a._v(" "),s("p",[a._v("park 方法有很多变种，用于实现不同场景的 park 功能，但是 park 功能本身还是依赖于 "),s("code",[a._v("Unsafe.park")]),a._v("。")]),a._v(" "),s("p",[a._v("调用 "),s("code",[a._v("Unsafe.park")]),a._v(" 后会阻塞当前线程，直到以下情况之一发生：")]),a._v(" "),s("ul",[s("li",[a._v("调用了 "),s("code",[a._v("unpark")]),a._v(" 函数，释放了该线程的许可。")]),a._v(" "),s("li",[a._v("该线程被中断。")]),a._v(" "),s("li",[a._v("park 设置的限制时间到了。")])]),a._v(" "),s("p",[a._v("需要注意这里是阻塞线程，而不是挂起线程，实际效果和 Thread.sleep() 方法类似。")]),a._v(" "),s("h4",{attrs:{id:"_1-2-1-park-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-park-方法"}},[a._v("#")]),a._v(" 1.2.1 park 方法")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("public static void park();  // 直接调用 Unsafe.park(false, 0L)\n\npublic static void park(Object blocker);  // 调用 Unsafe.park(false, 0L) 之前先把 blocker 设置到当前线程的 parkBlocker 字段\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("h4",{attrs:{id:"_1-2-2-parknanos-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-2-parknanos-方法"}},[a._v("#")]),a._v(" 1.2.2 parkNanos 方法")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("public static void parkNanos(Object blocker, long nanos); // 调用 Unsafe.park(false, nanos) 之前先把 blocker 设置到当前线程的 parkBlocker 字段\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("额外传入一个等待时间，等待时间完会自动解除阻塞。")]),a._v(" "),s("h4",{attrs:{id:"_1-2-3-parkuntil-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-parkuntil-方法"}},[a._v("#")]),a._v(" 1.2.3 parkUntil 方法")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("public static void parkUntil(Object blocker, long deadline);  // 调用 Unsafe.park(true, deadline) 之前先把 blocker 设置到当前线程的 parkBlocker 字段\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("额外传入一个指定的时间点，到了指定时间点会自动解除阻塞。")]),a._v(" "),s("h3",{attrs:{id:"_1-3-unpark"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-unpark"}},[a._v("#")]),a._v(" 1.3 unpark")]),a._v(" "),s("p",[a._v("从方法声明上看：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("public static void unpark(Thread thread);\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("需要传入指定线程作为参数，如果线程正被 park，则解除阻塞状态；否则让下一次 park 失效。")]),a._v(" "),s("p",[a._v("如果线程还没有启动，不保证有任何效果。")]),a._v(" "),s("h2",{attrs:{id:"_2-使用示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用示例"}},[a._v("#")]),a._v(" 2. 使用示例")]),a._v(" "),s("h3",{attrs:{id:"_2-1-使用-park-unpark-实现线程同步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-使用-park-unpark-实现线程同步"}},[a._v("#")]),a._v(" 2.1 使用 park/unpark 实现线程同步")]),a._v(" "),s("h3",{attrs:{id:"_2-2-中断响应"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-中断响应"}},[a._v("#")]),a._v(" 2.2 中断响应")]),a._v(" "),s("p",[a._v("中断线程后，会退出阻塞。")])])}),[],!1,null,null,null);r.default=e.exports}}]);