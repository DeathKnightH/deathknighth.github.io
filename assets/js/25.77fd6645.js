(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{383:function(_,v,t){"use strict";t.r(v);var a=t(44),r=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"数据库设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库设计"}},[_._v("#")]),_._v(" 数据库设计")]),_._v(" "),t("h2",{attrs:{id:"_1-设计理论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-设计理论"}},[_._v("#")]),_._v(" 1. 设计理论")]),_._v(" "),t("h3",{attrs:{id:"_1-1-名词解释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-名词解释"}},[_._v("#")]),_._v(" 1.1 名词解释")]),_._v(" "),t("ul",[t("li",[_._v("Table（表）：数据库的数据的一个集合，由多个列和行组成，同一张表的数据共用同样的列。")]),_._v(" "),t("li",[_._v("Attribute（属性）：表的列名。")]),_._v(" "),t("li",[_._v("Tuple（元组）：表的一行数据。")]),_._v(" "),t("li",[_._v("Domain（域）：属性的数据类型。")]),_._v(" "),t("li",[_._v("Relation（依赖）：属性之间存在的某种联系。")]),_._v(" "),t("li",[_._v("Schema（模式）：逻辑结构，属性在逻辑上组成的集合。")]),_._v(" "),t("li",[_._v("Key（键）：由一个或多个属性组成的一个整体，通常是有唯一性的（即当两个元组的键相同，则其所有属性都相同）。一个属性可以存在于不同的键中，一张表也可以有多个键。")]),_._v(" "),t("li",[_._v("Primary key（主键）：唯一性标识，不可为空，一个表中只能有一个主键。")]),_._v(" "),t("li",[_._v("Candidate key（候选键）：由一个或多个属性组成的一个整体，具有主键的特征，都有资格成为主键。")]),_._v(" "),t("li",[_._v("Super key（超键）：键的超集，包含键的属性集合。")]),_._v(" "),t("li",[_._v("Foreign key（外键）：在关系 A 中的一个或多个属性在关系 B 中是一个 key，那么该属性集合在 A 中被称为外键。")]),_._v(" "),t("li",[_._v("Prime attribute（主属性）：所有候选键里包含的属性都是主属性。")]),_._v(" "),t("li",[_._v("Projection（投影）：")]),_._v(" "),t("li",[_._v("Selection（选择）：按一定条件选择元组。")]),_._v(" "),t("li",[_._v("Cross join（交叉连接）：又称笛卡尔积，将关系 A 和关系 B 中的每一行进行组合，保留所有组合结果。")]),_._v(" "),t("li",[_._v("Natural join（自然连接）：将关系 A 和关系 B 中的每一行进行匹配，只保留相同的部分，去掉不匹配的部分。")]),_._v(" "),t("li",[_._v("Theta join（θ连接）：又称连接，带约束条件的笛卡尔积。即在两个关系的笛卡尔积中根据条件过滤获取符合条件元组集合。")]),_._v(" "),t("li",[_._v("Outer join（外连接）：自然连接时将不匹配的部分属性置为 null，并加入结果集。")]),_._v(" "),t("li",[_._v("Division（除法运算）：关系 A 除以关系 B 得到结果 T，T 的属性是所有在 A 中但不在 B 中的属性集合，T 的元组包含了 A 所有元组和 B 所有的元组的一一组合。")])]),_._v(" "),t("h3",{attrs:{id:"_1-2-函数依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-函数依赖"}},[_._v("#")]),_._v(" 1.2 函数依赖")]),_._v(" "),t("p",[_._v("在一个关系 R 中，属性组 A 的值由属性组 B 决定，即唯一确定的 B 能确定唯一的 A 值。")]),_._v(" "),t("ul",[t("li",[_._v("完全函数依赖：必须由完整的一组 B 属性才能决定 A。")]),_._v(" "),t("li",[_._v("部分函数依赖：B 中的部分属性也可以决定 A。")]),_._v(" "),t("li",[_._v("传递函数依赖：属性组 A 决定 B，B 决定 C，且同时满足，B/C 均不包含于 A，C 不包含于 B，B 不能决定 A，则说 C 传递依赖于 A。")])]),_._v(" "),t("h3",{attrs:{id:"_1-3-异常和范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-异常和范式"}},[_._v("#")]),_._v(" 1.3 异常和范式")]),_._v(" "),t("h4",{attrs:{id:"_1-3-1-异常"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-1-异常"}},[_._v("#")]),_._v(" 1.3.1 异常")]),_._v(" "),t("p",[_._v("不符合范式会造成异常。\n以一张学生选课表为例：\n学号, 姓名, 年龄, 课程名称, 成绩, 学分")]),_._v(" "),t("ul",[t("li",[_._v("数据冗余：同一个学生选修了 n 门课，则 (学号，姓名，年龄)在表中重复了 n 次。")]),_._v(" "),t("li",[_._v("修改异常：如果修改一门课的学分，那么要同时修改选了这门课的所有学生对应的元组的学分，否则或造成修改异常。")]),_._v(" "),t("li",[_._v("删除异常：如果删除一门课，那么要同时删除选了这门课所有学生对应的元组，否则会造成删除异常。")]),_._v(" "),t("li",[_._v("插入异常：插入一个元组，如果课程不存在，则会造成插入异常。")])]),_._v(" "),t("h4",{attrs:{id:"_1-3-2-1nf-第一范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-2-1nf-第一范式"}},[_._v("#")]),_._v(" 1.3.2 1NF 第一范式")]),_._v(" "),t("p",[_._v("定义：属性不可分。\n理解：一列只能表示单一的属性，不能把多种属性合并到一列。\n实现方式：不用特地去实现，现代关系型数据库的表天然就是符合第一范式的，每个属性(列)只能使用一种类型。")]),_._v(" "),t("h4",{attrs:{id:"_1-3-3-2nf-第二范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-3-2nf-第二范式"}},[_._v("#")]),_._v(" 1.3.3 2NF 第二范式")]),_._v(" "),t("p",[_._v("定义：在满足 1NF 的前提下，每个非主属性都完全依赖于键码。\n理解：在 1NF 的基础上，消除部分依赖。\n实现方式：拆分表属性，还是以上述学生选课表为例：\n(学号,课程名称) 是候选键，但是其中(学号)能决定(姓名,年龄)，同时(课程名称)能决定(学分)，有部分函数依赖。\n实现 2NF 的方式是拆分表的属性，最后形成 3 张表：\n学号，姓名，年龄")]),_._v(" "),t("p",[_._v("课程名称，学分")]),_._v(" "),t("p",[_._v("学号，课程名称，成绩")]),_._v(" "),t("p",[_._v("这样就消除了候选键的部分依赖，满足了 2NF。")]),_._v(" "),t("p",[_._v("但是结果的 3 张表依旧存在异常，")]),_._v(" "),t("h4",{attrs:{id:"_1-3-4-3nf-第三范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-4-3nf-第三范式"}},[_._v("#")]),_._v(" 1.3.4 3NF 第三范式")]),_._v(" "),t("p",[_._v("定义：在满足 2NF 的前提下，每个非主属性都不传递依赖于键码。\n理解：在 2NF 的基础上，消除传递依赖。\n实现方式：还是拆分表属性，")]),_._v(" "),t("h2",{attrs:{id:"_2-设计流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-设计流程"}},[_._v("#")]),_._v(" 2. 设计流程")])])}),[],!1,null,null,null);v.default=r.exports}}]);