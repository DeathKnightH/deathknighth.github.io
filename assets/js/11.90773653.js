(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{376:function(a,t,_){a.exports=_.p+"assets/img/adapter.drawio.1ef1c367.png"},377:function(a,t,_){a.exports=_.p+"assets/img/adapter.classextends.drawio.4d2d6246.png"},454:function(a,t,_){"use strict";_.r(t);var v=_(44),s=Object(v.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"适配器模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式"}},[a._v("#")]),a._v(" 适配器模式")]),a._v(" "),v("h2",{attrs:{id:"_1-概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念"}},[a._v("#")]),a._v(" 1. 概念")]),a._v(" "),v("p",[a._v("Adapter 又称封装器模式，是一种结构型设计模式，目的是使接口不兼容的对象能互相适配。")]),a._v(" "),v("h2",{attrs:{id:"_2-意图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-意图"}},[a._v("#")]),a._v(" 2. 意图")]),a._v(" "),v("p",[a._v("封装复杂的对象转换过程，甚至可以通过实现业务逻辑接口的方式来隐藏适配器自身的存在(即业务代码无法感知适配器的存在)。")]),a._v(" "),v("h2",{attrs:{id:"_3-类图示例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-类图示例"}},[a._v("#")]),a._v(" 3. 类图示例")]),a._v(" "),v("p",[a._v("可以通过适配的层次不同分为两种：")]),a._v(" "),v("p",[a._v("1、 对象适配器")]),a._v(" "),v("p",[v("img",{attrs:{src:_(376),alt:"object adapter"}})]),a._v(" "),v("p",[a._v("adapter 在实现时使用了构成原则：")]),a._v(" "),v("ul",[v("li",[a._v("适配器直接实现了业务对象的接口，把自己作为业务对象实例。")]),a._v(" "),v("li",[a._v("适配器内部封装了另一个 Service 对象，这个 service 对象才是需要适配的实现了实际功能的对象。")])]),a._v(" "),v("p",[a._v("2、类适配器")]),a._v(" "),v("p",[v("img",{attrs:{src:_(377),alt:"object adapter"}})]),a._v(" "),v("p",[a._v("类适配器使用了继承机制：")]),a._v(" "),v("ul",[v("li",[a._v("adapter 同时继承两个不兼容的对象。")]),a._v(" "),v("li",[a._v("在 adapter 中重写的方法里直接进行适配。")])]),a._v(" "),v("p",[a._v("这种方式有一个局限性，只能在支持多重继承的语言中才能实现，比如 C++。")]),a._v(" "),v("h2",{attrs:{id:"_4-适用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-适用场景"}},[a._v("#")]),a._v(" 4. 适用场景")]),a._v(" "),v("h3",{attrs:{id:"_4-1-实际业务场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-实际业务场景"}},[a._v("#")]),a._v(" 4.1 实际业务场景")]),a._v(" "),v("ul",[v("li",[a._v("两个系统对接，一个系统产生的数据格式不能直接被另一个系统使用，比如某个系统导出的分析数据是 xml 格式的，另一个系统是使用excel文件进行分析的，可以使用适配器模式：\n"),v("ul",[v("li",[a._v("创建一个 xml-excel 适配器，内部实现 xml 和 excel 格式互转。")]),a._v(" "),v("li",[a._v("也可以直接适配分析代码，创建一个 xml 适配器，直接和分析业务的代码对接，不经过 excel 转换。")])])]),a._v(" "),v("li",[a._v("在业务扩展过程中，可能出现一系列新的对象，他们都统一提供了某种额外的功能，如果直接扩展需要改动所有使用了这类对象的代码，这时也可以使用适配器模式：\n"),v("ul",[v("li",[a._v("将额外扩展的功能放到适配器中，这样其实更像装饰器模式。")])])])]),a._v(" "),v("h3",{attrs:{id:"_4-2-开源实例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-开源实例"}},[a._v("#")]),a._v(" 4.2 开源实例")]),a._v(" "),v("p",[a._v("JDK 中：")]),a._v(" "),v("ul",[v("li",[a._v("java.util.Arrays#asList()")]),a._v(" "),v("li",[a._v("java.util.Collections#list()")])]),a._v(" "),v("p",[a._v("各种bean映射转换器：")]),a._v(" "),v("ul",[v("li",[a._v("mapstruct")]),a._v(" "),v("li",[a._v("dozer（已经基本不更新了）")])]),a._v(" "),v("h2",{attrs:{id:"_5-实现细节和技巧"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-实现细节和技巧"}},[a._v("#")]),a._v(" 5. 实现细节和技巧")]),a._v(" "),v("ul",[v("li",[a._v("只对确实不兼容且难以修改的接口使用适配器模式，如果目标对象代码是可以修改的，可能在目标对象里直接添加接口更容易一些。")]),a._v(" "),v("li",[a._v("最好是业务代码通过接口来使用适配器，这需要平时就养成使用接口解耦代码的好习惯。")])]),a._v(" "),v("h2",{attrs:{id:"_6-优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-优缺点"}},[a._v("#")]),a._v(" 6. 优缺点")]),a._v(" "),v("p",[a._v("优点：")]),a._v(" "),v("ul",[v("li",[a._v("符合单一职责原则。数据/接口转换的代码与主要业务解耦。")]),a._v(" "),v("li",[a._v("符合开闭原则。只要业务代码通过接口和适配器交互，那么就可以随意扩展适配器而不影响现有业务代码。")])]),a._v(" "),v("p",[a._v("缺点：")]),a._v(" "),v("ul",[v("li",[a._v("增加代码层次和数量，有时候直接新增转换方法更快速便捷。")])]),a._v(" "),v("h2",{attrs:{id:"_7-与其他设计模式的关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-与其他设计模式的关系"}},[a._v("#")]),a._v(" 7. 与其他设计模式的关系")])])}),[],!1,null,null,null);t.default=s.exports}}]);