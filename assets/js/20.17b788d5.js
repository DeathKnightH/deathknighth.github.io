(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{377:function(t,v,_){"use strict";_.r(v);var r=_(44),n=Object(r.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"synchronized-关键字"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-关键字"}},[t._v("#")]),t._v(" synchronized 关键字")]),t._v(" "),_("p",[t._v("​")]),t._v(" "),_("h2",{attrs:{id:"_1-原理分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-原理分析"}},[t._v("#")]),t._v(" 1. 原理分析")]),t._v(" "),_("p",[t._v("​\tsynchronized 关键字实现线程安全的原理：保证可见性，可重入，互斥锁的加解锁。")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("互斥锁的加解锁")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("private int count = 0;\n\npublic void increase(int n){\n\tsynchronized(this){\n\t\tcount += n;\n\t}\n}\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br"),_("span",{staticClass:"line-number"},[t._v("7")]),_("br")])]),_("p",[t._v("用以上代码编译出来的 class 用 "),_("code",[t._v("javap -v")]),t._v(" 反编译看到的字节码如下：")]),t._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5Cdeath%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210703142233591.png",alt:"image-20210703142233591"}})]),t._v(" "),_("ul",[_("li",[t._v("monitorenter 指令发生在加锁时，使加锁对象的锁计数器 +1；")]),t._v(" "),_("li",[t._v("monitorexit 指令发生在释放锁时，使加锁对象的锁计数器 -1；")])]),t._v(" "),_("p",[_("strong",[t._v("monitor")]),t._v(" 和 **被监视对象（object）**和 "),_("strong",[t._v("线程")]),t._v(" 互相之间只能是 一对一 的绑定关系。")]),t._v(" "),_("p",[t._v("enter 和 exit 的流程如下图所示：")]),t._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5Cdeath%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210703153350874.png",alt:"image-20210703153350874"}})])]),t._v(" "),_("li",[_("p",[t._v("可重入")]),t._v(" "),_("p",[t._v("​\t由上面对 monitor 的描述可知，被监视对象拥有一个锁计数器，每次同一个线程 monitorenter 就 +1，计数器的值就是重入的次数。相对的，每次 monitorexit 就 -1，如果 -1 后计数器不为0，说明当前线程仍持有锁，上次 enter 是一次重入；如果 -1 后计数器为 0，说明当前线程释放了锁，这时其他线程就可以来尝试 monitorenter 了。")]),t._v(" "),_("p",[t._v("​\t可重入可以让同一个线程在持有当前对象锁的情况下无需等待就可以直接获取当前对象锁，继续执行同步语句，不会造成一个线程在持有一个对象锁时无法再获取同一个对象的锁，导致自己等待自己的死锁形成。")])]),t._v(" "),_("li",[_("p",[t._v("保证可见性")]),t._v(" "),_("p",[t._v("根据 Happens-before 原则：对同一个监视器的解锁，happens-before于对该监视器的加锁。")])])]),t._v(" "),_("h2",{attrs:{id:"_2-synchronized-优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-synchronized-优化"}},[t._v("#")]),t._v(" 2. synchronized 优化")]),t._v(" "),_("p",[t._v("​\t\tmonitorenter 和 monitorexit 依赖于操作系统的 Mutex Lock来实现，在调用时会切换用户态和内核态，对于运行在单线程上的 synchronized 语句块，可能切换的时间比执行语句还要长，造成严重的性能损失，于是在jdk1.6后对 synchronized 的实现引入了大量的优化来减少锁操作的开销。")]),t._v(" "),_("p",[t._v("​\t这些优化属于 JVM 层面的优化，单看反编译字节码是没有变化的。")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("锁消除")]),t._v(" "),_("p",[t._v("​\t虚拟机的即时编译器在运行时，对一些在代码上写了同步语句的，但是编译器检测到不可能发生共享数据竞争，就会消除该锁，该机制依赖于逃逸分析。")]),t._v(" "),_("p",[t._v("举例：")]),t._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" s "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" s1 "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" s2 "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" s3"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br")])]),_("p",[t._v("​\t在 jdk 1.6之前，这里会编译为线程安全的 StringBuffer连续append，而在 jdk1.6 之后由于判断这一行代码不可能发生逃逸，于是会改为非线程安全的 StringBuilder 连续的 append。")])]),t._v(" "),_("li",[_("p",[t._v("偏向锁")]),t._v(" "),_("p",[t._v("​\t当一个线程访问同步快并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和推出同步块时不需要进行CAS操作来加锁和解锁。只需要简单地测试一下对象头的"),_("code",[t._v("Mark Word")]),t._v("里是否存储着指向当前线程的偏向锁。")]),t._v(" "),_("p",[t._v("​\t如果成功，表示线程已经获取到了锁；")]),t._v(" "),_("p",[t._v("​\t如果失败即偏向锁指向其他线程，会先进行CAS替换存储的线程ID，")]),t._v(" "),_("ul",[_("li",[t._v("替换成功会继续获取偏向锁。")]),t._v(" "),_("li",[t._v("反之 CAS 操作失败，会进行偏向锁撤销，然后锁升级为轻量级锁。")])]),t._v(" "),_("p",[t._v("​\t"),_("strong",[t._v("偏向锁撤销")]),t._v(" 会一直等到竞争出现才会进行，并且要等待原持有偏向锁的线程到达"),_("strong",[t._v("全局安全点")]),t._v("（即该线程没有正在执行的字节码）时才会暂停原持有偏向锁的线程，并检查持有偏向锁的线程是否活着。")]),t._v(" "),_("ul",[_("li",[t._v("如果活着，且未退出同步块，就会升级为轻量级锁。")]),t._v(" "),_("li",[t._v("如果活着，但已退出同步块，会遍历栈帧替换线程ID偏向其他线程，或者设置为无锁状态。")]),t._v(" "),_("li",[t._v("如果不处于活动状态，也会遍历栈帧替换线程ID偏向其他线程，或者设置为无锁状态。")])])]),t._v(" "),_("li",[_("p",[t._v("轻量级锁")]),t._v(" "),_("p",[t._v("​\t轻量级锁，用于在无实际竞争但有多个线程使用同步块的情况，减少重量级锁在线程阻塞时造成的线程开销。轻量级锁定情况下 Mark Word 中锁标志位置为 00。")]),t._v(" "),_("p",[t._v("​\t轻量级锁不需要申请互斥量，只需要 CAS 替换对象头中的锁记录，锁记录存储于线程的虚拟机栈中。")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("如果 CAS 成功，当前线程就获取了锁，Mark Word 中存储的数据为指向锁记录的指针。")])]),t._v(" "),_("li",[_("p",[t._v("如果 CAS 失败，先检查当前 Mark Word 中是否存在指向当前线程栈的指针。")]),t._v(" "),_("ul",[_("li",[t._v("如果有，说明已获取锁，可以直接调用。")]),t._v(" "),_("li",[t._v("否则说明可能存在竞争，此时会尝试自旋获取锁，如果自旋 一段时间还是不能获取锁，说明竞争比较激烈，此时会升级为重量级锁。")])])])])]),t._v(" "),_("li",[_("p",[t._v("锁粗化")]),t._v(" "),_("p",[t._v("​\t绝大多数情况下，锁的粒度都是越小越好，比如 synchronized 同步块包括的代码范围越小，需要执行的同步操作越少，其他等待锁的线程可以尽早地获取锁。")]),t._v(" "),_("p",[t._v("​\t但是如果存在连续的一系列操作都是对同一个对象反复加锁/解锁，或者同步块出现在循环体中时，频繁加解锁会造成不必要的额外开销，这时，JVM 会将锁范围"),_("strong",[t._v("粗化")]),t._v("到连续操作的外部。")])]),t._v(" "),_("li",[_("p",[t._v("自适应自旋锁")]),t._v(" "),_("p",[t._v("​\t自旋锁是为了降低频繁挂起和恢复阻塞线程带来的性能开销，因为大多数共享数据的锁定状态持续时间很短，此时可以让等待线程执行一个忙循环，等待一小段时间再去尝试获取锁，而不用挂起，这就是自旋锁。")]),t._v(" "),_("p",[t._v("​\t从 JDK 1.4 开始就有自旋锁，直到 JDK 1.6 才默认打开，默认自旋次数为 10，可通过 "),_("code",[t._v("-XX:PreBlcokSpin")]),t._v(" 参数来更改自旋次数。")]),t._v(" "),_("p",[t._v("​\tJDK 1.6 后引入了自适应自旋锁，增加了自旋次数和是否使用自旋的灵活性，JVM会根据前一次在同一个锁上的自旋时间及当前锁拥有者的状态决定。")]),t._v(" "),_("ul",[_("li",[t._v("如果上次自旋获得过锁，JVM会适当增加自旋次数，以期用自旋锁再次获得锁。")]),t._v(" "),_("li",[t._v("如果上次自旋失败，JVM可能会取消掉自旋过程，直接挂起。")])])])]),t._v(" "),_("h2",{attrs:{id:"_3-锁升级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-锁升级"}},[t._v("#")]),t._v(" 3. 锁升级")]),t._v(" "),_("p",[t._v("​\t锁升级的大致流程：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://blog.dreamtobe.cn/img/java_synchronized.png",alt:"img"}})]),t._v(" "),_("p",[t._v("以上图片来自于 https://blog.dreamtobe.cn/2015/11/13/java_synchronized/")]),t._v(" "),_("h2",{attrs:{id:"_4-不同锁的对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-不同锁的对比"}},[t._v("#")]),t._v(" 4. 不同锁的对比")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("类型")]),t._v(" "),_("th",[t._v("适用场景")]),t._v(" "),_("th",[t._v("升级场景")]),t._v(" "),_("th",[t._v("与下一级比较的优势")]),t._v(" "),_("th",[t._v("缺点")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("无锁")]),t._v(" "),_("td",[t._v("JVM判断不存在共享数据竞争")]),t._v(" "),_("td",[t._v("即时编译器判断有额外的线程可能访问同步块")]),t._v(" "),_("td",[t._v("最快的执行时间")]),t._v(" "),_("td",[t._v("\\")])]),t._v(" "),_("tr",[_("td",[t._v("偏向锁")]),t._v(" "),_("td",[t._v("实际只有一个线程访问同步块")]),t._v(" "),_("td",[t._v("有第二个线程访问同步块，且第一次 CAS 替换失败")]),t._v(" "),_("td",[t._v("最多只有一次CAS，与无锁比时间差距仅ns级")]),t._v(" "),_("td",[t._v("偏向锁撤销会有较大开销")])]),t._v(" "),_("tr",[_("td",[t._v("轻量级锁")]),t._v(" "),_("td",[t._v("竞争很少时，响应时间短")]),t._v(" "),_("td",[t._v("竞争激烈时，有一个线程自旋多次仍获取不到锁")]),t._v(" "),_("td",[t._v("没有挂起/恢复操作，不需要切换用户态")]),t._v(" "),_("td",[t._v("竞争激烈时，自旋会消耗CPU性能")])]),t._v(" "),_("tr",[_("td",[t._v("重量级锁")]),t._v(" "),_("td",[t._v("竞争激烈时，保证吞吐量")]),t._v(" "),_("td",[t._v("\\")]),t._v(" "),_("td",[t._v("\\")]),t._v(" "),_("td",[t._v("频繁地加解锁会导致操作系统频繁地切换用户态和内核态，造成很大的性能开销")])])])]),t._v(" "),_("h2",{attrs:{id:"_5-synchronized-与-reentrantlock-比较"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-synchronized-与-reentrantlock-比较"}},[t._v("#")]),t._v(" 5. synchronized 与 ReentrantLock 比较")]),t._v(" "),_("p",[t._v("​\t这里只列出不同点中各自的"),_("strong",[t._v("优点")]),t._v("：")]),t._v(" "),_("ul",[_("li",[t._v("synchronized：\n"),_("ul",[_("li",[t._v("基于JVM实现，简单易用，性能上与 ReentrantLock 基本没有差距。")]),t._v(" "),_("li",[t._v("JVM针对 synchronized 有许多优化，如锁粗化、锁消除等。")])])]),t._v(" "),_("li",[t._v("ReentrantLock：\n"),_("ul",[_("li",[t._v("可以选择公平锁还是非公平锁。")]),t._v(" "),_("li",[t._v("可以在尝试获取锁时中断或设置超时时间，避免死锁。")]),t._v(" "),_("li",[t._v("可以通过 Condition 设置更灵活的锁条件。")]),t._v(" "),_("li",[t._v("可以通过 tryLock() 的返回值判断是否获取到锁。")])])])])])}),[],!1,null,null,null);v.default=n.exports}}]);