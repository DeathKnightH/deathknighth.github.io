(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{383:function(a,t,_){"use strict";_.r(t);var r=_(44),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"核心知识点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#核心知识点"}},[a._v("#")]),a._v(" 核心知识点")]),a._v(" "),_("h2",{attrs:{id:"_1-事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-事务"}},[a._v("#")]),a._v(" 1. 事务")]),a._v(" "),_("h3",{attrs:{id:"_1-1-acid"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-acid"}},[a._v("#")]),a._v(" 1.1 ACID")]),a._v(" "),_("ul",[_("li",[a._v("原子性：事务被视为不可分割的最基本单元，一个事务中的操作要么全部成功，要么全部失败回滚。")]),a._v(" "),_("li",[a._v("一致性：数据库在事务执行前后都处于一致性状态，在一致性状态下，所有事务对同一数据读取的状态是一致的。")]),a._v(" "),_("li",[a._v("隔离性：一个事务在提交之前，对其他事务不可见。")]),a._v(" "),_("li",[a._v("持久性：针对数据库崩溃的情况，保证事务一旦完成提交，则必须保证执行结果保存在数据库中不丢失。")])]),a._v(" "),_("h3",{attrs:{id:"_1-2-commit"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-commit"}},[a._v("#")]),a._v(" 1.2 commit")]),a._v(" "),_("p",[a._v("MySQL 有自动提交配置，默认为 true。")]),a._v(" "),_("p",[a._v("如果不需要自动提交事务，有两种方法：")]),a._v(" "),_("ul",[_("li",[a._v("将 "),_("code",[a._v("autocommit")]),a._v(" 配置设为 false。")]),a._v(" "),_("li",[a._v("使用 "),_("code",[a._v("START TRANSACTION")]),a._v("/"),_("code",[a._v("BEGIN")]),a._v(" 语句手动开启事务，使用 "),_("code",[a._v("ROLLBACK")]),a._v(" 回滚，使用 "),_("code",[a._v("COMMIT")]),a._v(" 提交。")])]),a._v(" "),_("h2",{attrs:{id:"_2-并发一致性问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-并发一致性问题"}},[a._v("#")]),a._v(" 2. 并发一致性问题")]),a._v(" "),_("p",[a._v("非并发环境中，只要满足了原子性，就可以保证事务的一致性。")]),a._v(" "),_("p",[a._v("并发环境下，如果仅满足原子性，会造成以下一致性问题：")]),a._v(" "),_("h3",{attrs:{id:"_2-1-丢失修改"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-丢失修改"}},[a._v("#")]),a._v(" 2.1 丢失修改")]),a._v(" "),_("h3",{attrs:{id:"_2-2-读脏数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-读脏数据"}},[a._v("#")]),a._v(" 2.2 读脏数据")]),a._v(" "),_("h3",{attrs:{id:"_2-3-不可重复读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-不可重复读"}},[a._v("#")]),a._v(" 2.3 不可重复读")]),a._v(" "),_("h3",{attrs:{id:"_2-4-幻读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-幻读"}},[a._v("#")]),a._v(" 2.4 幻读")]),a._v(" "),_("h2",{attrs:{id:"_3-锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-锁"}},[a._v("#")]),a._v(" 3. 锁")]),a._v(" "),_("p",[a._v("解决并发一致性问题，可以利用数据库自带的锁机制。")]),a._v(" "),_("h2",{attrs:{id:"_4-事务隔离级别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-事务隔离级别"}},[a._v("#")]),a._v(" 4. 事务隔离级别")]),a._v(" "),_("p",[a._v("由于锁需要自行手动操作，比较繁琐，在实际使用中更常用的是利用事务的隔离级别来处理并发一致性问题。")]),a._v(" "),_("p",[a._v("隔离级别分为 4 种。")]),a._v(" "),_("h3",{attrs:{id:"_4-1-read-uncommited-未提交读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-read-uncommited-未提交读"}},[a._v("#")]),a._v(" 4.1 Read uncommited 未提交读")]),a._v(" "),_("h3",{attrs:{id:"_4-2-read-commited-提交读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-read-commited-提交读"}},[a._v("#")]),a._v(" 4.2 Read commited 提交读")]),a._v(" "),_("h3",{attrs:{id:"_4-3-repeatable-read-可重复读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-repeatable-read-可重复读"}},[a._v("#")]),a._v(" 4.3 Repeatable read 可重复读")]),a._v(" "),_("h3",{attrs:{id:"_4-4-serializable-串行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-serializable-串行"}},[a._v("#")]),a._v(" 4.4 Serializable 串行")])])}),[],!1,null,null,null);t.default=e.exports}}]);