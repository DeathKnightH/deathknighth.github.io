(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{405:function(e,t,r){"use strict";r.r(t);var n=r(44),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"单调栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单调栈"}},[e._v("#")]),e._v(" 单调栈")]),e._v(" "),r("p",[e._v("Monotonic stack 是一种特殊的栈，栈中的元素保持单调递增/递减。")]),e._v(" "),r("p",[e._v("单调栈形式特殊，只用于解决一种典型问题："),r("code",[e._v("下一个更大/更小的元素")]),e._v("。即最终结果只与每次循环的下一个更大/更小的元素有关，其他元素可以忽略/抛弃。")]),e._v(" "),r("h2",{attrs:{id:"_1-基本思路"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本思路"}},[e._v("#")]),e._v(" 1. 基本思路")]),e._v(" "),r("p",[e._v("使用一个栈记录结果，以结果单调递增为例，从后向前遍历输入集合，当前元素 "),r("code",[e._v("current")]),e._v(" 入栈有两种操作：")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("current < stack.peek()")]),e._v(" 当前元素比栈顶小，直接入栈，然后遍历下一个元素。")]),e._v(" "),r("li",[r("code",[e._v("current > stack.peek()")]),e._v(" 当前元素比栈顶大，入栈会 "),r("code",[e._v("挡住")]),e._v(" 栈顶元素，由于问题的特殊性，被 "),r("code",[e._v("挡住")]),e._v(" 的元素与结果无关，需要循环出栈直到 "),r("code",[e._v("current < stack.peek()")]),e._v("，此时入栈 "),r("code",[e._v("current")]),e._v("。")])]),e._v(" "),r("p",[e._v("完整遍历整个集合后，栈中的元素就是单调递增排列的了（从栈顶至栈底）。")]),e._v(" "),r("p",[e._v("需要注意的细节：")]),e._v(" "),r("ul",[r("li",[e._v("重复元素，视情况，大多数情况下要求去重，此时在入栈前先判断 "),r("code",[e._v("current")]),e._v(" 是否在当前栈中，如果在就忽略，直接进入下一轮。")]),e._v(" "),r("li",[e._v("循环数组，有时输入集合是一个环状结构，此时有可能比 "),r("code",[e._v("current")]),e._v(" 大的元素在前方，需要循环绕一圈回来，解决思路是遍历两遍集合，在一遍遍历结束后接着从头开始遍历。")])]),e._v(" "),r("h2",{attrs:{id:"_2-伪代码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-伪代码"}},[e._v("#")]),e._v(" 2. 伪代码")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Stack<Integer> monotonicStack = new Stack<>();\nfor(int i = array.length - 1; i >= 0; i --){\n  int current = array[i];\n  if(monotonicStack.contains(curremt)){\n    continue;\n  }\n  while(!stack.isEmpty() && current > stack.peek()){\n    stack.pop();\n  }\n  stack.push(current);\n}\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br")])]),r("h2",{attrs:{id:"_3-习题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-习题"}},[e._v("#")]),e._v(" 3. 习题")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/problems/next-greater-element-i/",target:"_blank",rel:"noopener noreferrer"}},[e._v("496. 下一个更大元素 I"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/problems/next-greater-element-ii/",target:"_blank",rel:"noopener noreferrer"}},[e._v("503. 下一个更大元素 II"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/problems/daily-temperatures/",target:"_blank",rel:"noopener noreferrer"}},[e._v("739. 每日温度"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/problems/remove-duplicate-letters/",target:"_blank",rel:"noopener noreferrer"}},[e._v("316. 去除重复字母"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=a.exports}}]);