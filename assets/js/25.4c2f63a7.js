(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{397:function(a,t,r){"use strict";r.r(t);var _=r(44),s=Object(_.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"单源最短路径"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单源最短路径"}},[a._v("#")]),a._v(" 单源最短路径")]),a._v(" "),r("h2",{attrs:{id:"_1-定义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-定义"}},[a._v("#")]),a._v(" 1. 定义")]),a._v(" "),r("p",[r("strong",[a._v("问题场景：")]),a._v(" 给定一个带权重的有向图 G=(V,E) 和权重函数 w: E → R，定义图中一条路径 p=<v0,v1,...,vk> 的权重 w(p) 是构成该路径的所有边的权重之和。")]),a._v(" "),r("p",[r("strong",[a._v("最短路径：")]),a._v(" 从结点 u 到结点 v 的最短路径是 u~v 的所有路径中权重最小的路径。")]),a._v(" "),r("p",[r("strong",[a._v("单源：")]),a._v(" 指定一个源结点 s∈V，计算 s 到每一个结点 v∈V 的最短路径。")]),a._v(" "),r("h2",{attrs:{id:"_2-特殊情况"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-特殊情况"}},[a._v("#")]),a._v(" 2. 特殊情况")]),a._v(" "),r("h3",{attrs:{id:"_2-1-负权重的边"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-负权重的边"}},[a._v("#")]),a._v(" 2.1 负权重的边")]),a._v(" "),r("p",[a._v("如果只是一条负权重的边，没有形成负权重的环，是能够正常求出最短路径的。")]),a._v(" "),r("p",[a._v("反之，如果存在负权重的环，则无法得出最短路径，因为每经过一次环，权重之和都在减少。Bellman-Ford 算法可以检测到有向图中负权重环的存在。")]),a._v(" "),r("h3",{attrs:{id:"_2-2-环路"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-环路"}},[a._v("#")]),a._v(" 2.2 环路")]),a._v(" "),r("p",[a._v("可以证明存在最短路径时，这个最短路径一定不包含环。")]),a._v(" "),r("p",[a._v("证明思路：分3种情况讨论，环权重大于0，环权重小于0，环权重等于0.")]),a._v(" "),r("h2",{attrs:{id:"_3-性质"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-性质"}},[a._v("#")]),a._v(" 3. 性质")]),a._v(" "),r("h2",{attrs:{id:"_4-算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-算法"}},[a._v("#")]),a._v(" 4. 算法")]),a._v(" "),r("h3",{attrs:{id:"_4-1-基础"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-基础"}},[a._v("#")]),a._v(" 4.1 基础")]),a._v(" "),r("h4",{attrs:{id:"_4-1-1-前驱子图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-1-前驱子图"}},[a._v("#")]),a._v(" 4.1.1 前驱子图")]),a._v(" "),r("p",[a._v("定义每个节点的前驱节点和边组成的图。")]),a._v(" "),r("h4",{attrs:{id:"_4-1-2-relaxation-松弛操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-2-relaxation-松弛操作"}},[a._v("#")]),a._v(" 4.1.2 relaxation 松弛操作")]),a._v(" "),r("h3",{attrs:{id:"_4-2-bellman-ford-算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-bellman-ford-算法"}},[a._v("#")]),a._v(" 4.2 Bellman-Ford 算法")]),a._v(" "),r("p",[a._v("解决一般性的单源最短路径问题。")]),a._v(" "),r("h3",{attrs:{id:"_4-3-dijkstra-算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-dijkstra-算法"}},[a._v("#")]),a._v(" 4.3 Dijkstra 算法")]),a._v(" "),r("p",[a._v("解决带权重均为非负值情况下的单源最短路径问题。")])])}),[],!1,null,null,null);t.default=s.exports}}]);