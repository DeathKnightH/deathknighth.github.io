(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{419:function(_,v,e){"use strict";e.r(v);var t=e(44),a=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"mvcc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mvcc"}},[_._v("#")]),_._v(" MVCC")]),_._v(" "),e("p",[_._v("Muti-Version Concurrency Control，多版本并发控制，主流的RDBMS例如 Oracle/PostgreSQL/Microsoft SQL Server 都提供了 MVCC 能力。")]),_._v(" "),e("p",[_._v("在 MySQL 中 InnoDB/Falcon/Archive 等支持事务的引擎都使用了 MVCC。")]),_._v(" "),e("h2",{attrs:{id:"_1-基本概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本概念"}},[_._v("#")]),_._v(" 1. 基本概念")]),_._v(" "),e("h3",{attrs:{id:"_1-1-锁定读-locking-reads"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-锁定读-locking-reads"}},[_._v("#")]),_._v(" 1.1 锁定读（Locking Reads）")]),_._v(" "),e("p",[_._v("会读取数据的最新版本，因此又称当前读（current reads），锁定读会对数据加锁：")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("Select ... lock in share mode")]),_._v("：加 "),e("code",[_._v("S")]),_._v(" 锁，和 "),e("code",[_._v("X")]),_._v(" 锁互斥。但是不排斥其他 "),e("code",[_._v("S")]),_._v(" 锁。")]),_._v(" "),e("li",[e("code",[_._v("Select ... for update")]),_._v("、"),e("code",[_._v("insert")]),_._v("、"),e("code",[_._v("update")]),_._v("、"),e("code",[_._v("delete")]),_._v("：加 "),e("code",[_._v("X")]),_._v(" 锁，排斥其他所有锁。")])]),_._v(" "),e("h3",{attrs:{id:"_1-2-快照读-snapshot-reads"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-快照读-snapshot-reads"}},[_._v("#")]),_._v(" 1.2 快照读（snapshot reads）")]),_._v(" "),e("p",[_._v("会读取数据的快照，即当前时间点之前所有提交的事务。")]),_._v(" "),e("p",[_._v("所有不加锁的 "),e("code",[_._v("select")]),_._v(" 查询都是快照读。")]),_._v(" "),e("h2",{attrs:{id:"_2-解决的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-解决的问题"}},[_._v("#")]),_._v(" 2. 解决的问题")]),_._v(" "),e("p",[_._v("MVCC 的目的是减少锁的使用，同时保证事务的隔离性，主要解决以下问题：")]),_._v(" "),e("ul",[e("li",[_._v("解决读写之间的阻塞，提升并发事务的效率。")]),_._v(" "),e("li",[_._v("降低死锁的概率。")]),_._v(" "),e("li",[_._v("解决快照读的问题。")])]),_._v(" "),e("h2",{attrs:{id:"_3-基本原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-基本原理"}},[_._v("#")]),_._v(" 3. 基本原理")]),_._v(" "),e("p",[_._v("实现 MVCC 的基本思路就是通过数据行的多个版本管理来实现并发控制，简单来说就是保存数据的历史版本，通过版本号决定数据是否显示。")]),_._v(" "),e("p",[_._v("InnoDB 对 MVCC 的实现依赖于"),e("strong",[_._v("隐藏字段")]),_._v("、"),e("strong",[_._v("undo 日志")]),_._v("、"),e("strong",[_._v("Read View")]),_._v("。")]),_._v(" "),e("p",[_._v("这三者配合，再加上使用 "),e("code",[_._v("Read commited")]),_._v(" 或者 "),e("code",[_._v("Repeatable read")]),_._v(" 隔离级别，就可以实现 MVCC。")]),_._v(" "),e("h3",{attrs:{id:"_3-1-隐藏字段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-隐藏字段"}},[_._v("#")]),_._v(" 3.1 隐藏字段")]),_._v(" "),e("ul",[e("li",[_._v("db_row_id:6 byte，隐藏的自增行 ID，当建表时没有显示指定主键索引的话，InnoDB 会使用这个隐藏字段来创建默认的"),e("RouterLink",{attrs:{to:"/database/mysql/"}},[_._v("主键索引")]),_._v("。")],1),_._v(" "),e("li",[_._v("db_trx_id:6 byte，最后一个修改该行的事务的 ID。创建行/修改行都会记录。")]),_._v(" "),e("li",[_._v("db_roll_ptr:7 byte，回滚指针，指向这行记录的 Undo log 信息。")])]),_._v(" "),e("h3",{attrs:{id:"_3-2-undo-log"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-undo-log"}},[_._v("#")]),_._v(" 3.2 Undo log")]),_._v(" "),e("p",[e("RouterLink",{attrs:{to:"/database/mysql/MySQL_Log.html"}},[_._v("Undo log")]),_._v(" 保存了所有的事务操作，行数据的快照保存在 undo segment 中。")],1),_._v(" "),e("p",[e("code",[_._v("db_roll_ptr")]),_._v(" 指针会把该数据行的所有快照记录通过链表结构串联起来，每一个当前行的指针指向上一个版本的行数据快照。")]),_._v(" "),e("h3",{attrs:{id:"_3-3-read-view-与可见性算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-read-view-与可见性算法"}},[_._v("#")]),_._v(" 3.3 Read View 与可见性算法")]),_._v(" "),e("p",[e("code",[_._v("Read View")]),_._v(" 保存了当前事务开启时所有活跃（还未提交）的事务列表。为了实现 MVCC 而不是简单的把 Read View 中所有的事务均认定为不可见，需要一种可见性算法来计算各事务间的数据可见性。")]),_._v(" "),e("p",[_._v("这里需要用到 "),e("code",[_._v("Read View")]),_._v(" 中记录的几个重要的属性：")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("trx_ids")]),_._v("：当前正在活跃（还未提交）的事务 ID 合集。")]),_._v(" "),e("li",[e("code",[_._v("low_limit_id")]),_._v("：活跃事务中最大的事务 ID。")]),_._v(" "),e("li",[e("code",[_._v("up_limit_id")]),_._v("：活跃事务中最小的事务 ID。")]),_._v(" "),e("li",[e("code",[_._v("creator_trx_id")]),_._v("：创建这个 "),e("code",[_._v("Read View")]),_._v(" 的事务 ID。")])]),_._v(" "),e("p",[_._v("假设当前事务的 ID 为 "),e("code",[_._v("trx_id")]),_._v("，按以下顺序判断：\n1、 "),e("code",[_._v("trx_id")]),_._v(" < "),e("code",[_._v("up_limit_id")]),_._v("：说明 "),e("code",[_._v("trx_id")]),_._v(" 发生在所有活跃事务创建之前，所以当前行对 "),e("code",[_._v("trx_id")]),_._v(" 事务可见。\n2、 "),e("code",[_._v("trx_id")]),_._v(" >= "),e("code",[_._v("low_limit_id")]),_._v("：说明 "),e("code",[_._v("trx_id")]),_._v(" 发生在所有活跃事务创建之后，所以当前行对 "),e("code",[_._v("trx_id")]),_._v(" 事务不可见。\n3、 判断 "),e("code",[_._v("trx_id")]),_._v(" 是否在 "),e("code",[_._v("trx_ids")]),_._v(" 集合中，如果在，说明当前事务还未提交，当前行不可见。如果不在，说明当前事务已提交，当前行可见。")])])}),[],!1,null,null,null);v.default=a.exports}}]);