(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{398:function(a,s,t){"use strict";t.r(s);var e=t(44),n=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"lru-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lru-算法"}},[a._v("#")]),a._v(" LRU 算法")]),a._v(" "),t("h2",{attrs:{id:"_0-概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0-概念"}},[a._v("#")]),a._v(" 0. 概念")]),a._v(" "),t("p",[a._v("LRU（Least Recently Used）是一种常见的缓存淘汰策略，即淘汰"),t("code",[a._v("最近最少使用")]),a._v("的部分。")]),a._v(" "),t("p",[a._v("常用于各类缓存场景，例如 ecache、redis。")]),a._v(" "),t("h2",{attrs:{id:"_1-算法描述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-算法描述"}},[a._v("#")]),a._v(" 1. 算法描述")]),a._v(" "),t("p",[a._v("对外暴露以下接口：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("class LRUCache {\n    // 构造时传入缓存容量\n    public LRUCache(int capacity) {\n\n    }\n    \n    // 随机取，key 不存在缓存中就返回 -1\n    public int get(int key) {\n\n    }\n    \n    // 随机存，如果 key 存在缓存中则刷新其 value 值\n    public void put(int key, int value) {\n\n    }\n}\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br"),t("span",{staticClass:"line-number"},[a._v("16")]),t("br")])]),t("p",[a._v("由于是 LRU 算法，所以当缓存中 key 的数量达到容量上限时，再放入新的 key，就会先删除缓存中最近最少使用的 key，再将新 key 存入。")]),a._v(" "),t("h2",{attrs:{id:"_2-算法设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-算法设计"}},[a._v("#")]),a._v(" 2. 算法设计")]),a._v(" "),t("p",[a._v("分析算法要求：")]),a._v(" "),t("p",[a._v("1、get 接口需要快速的随机读取。")]),a._v(" "),t("p",[a._v("2、LRU 策略要求内部元素按照最近使用时序排序，这样容量满了之后能很方便地删除最久未使用的元素。")]),a._v(" "),t("p",[a._v("3、每次取元素都要将对应元素更新为最近使用，综合2/3两点，需要在头尾位置快速删除、添加元素。")]),a._v(" "),t("p",[a._v("Hash 表可以快速随机读取，而双向链表可以保证元素有序排列的同时能快速在头尾删除、添加元素。两者结合就是 LRU 算法的核心，在 Java 中与之对应的就是 "),t("code",[a._v("LinkedHashMap")]),a._v("。")]),a._v(" "),t("h2",{attrs:{id:"_3-算法实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-算法实现"}},[a._v("#")]),a._v(" 3. 算法实现")]),a._v(" "),t("h3",{attrs:{id:"_3-1-手搓轮子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-手搓轮子"}},[a._v("#")]),a._v(" 3.1 手搓轮子")]),a._v(" "),t("h3",{attrs:{id:"_3-2-使用现有类库的-linkedhashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-使用现有类库的-linkedhashmap"}},[a._v("#")]),a._v(" 3.2 使用现有类库的 LinkedHashMap")])])}),[],!1,null,null,null);s.default=n.exports}}]);