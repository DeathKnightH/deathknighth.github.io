(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{386:function(e,a,t){e.exports=t.p+"assets/img/ReentrantLock_tryAcquire.8713f7f3.png"},387:function(e,a,t){e.exports=t.p+"assets/img/CyclicBarrier_dowait.1221dab1.png"},486:function(e,a,t){"use strict";t.r(a);var r=t(44),s=Object(r.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"aqs-abstract-queued-synchronizer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aqs-abstract-queued-synchronizer"}},[e._v("#")]),e._v(" AQS(Abstract Queued Synchronizer)")]),e._v(" "),r("h2",{attrs:{id:"_1-核心思想"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-核心思想"}},[e._v("#")]),e._v(" 1. 核心思想")]),e._v(" "),r("ul",[r("li",[e._v("如果被请求的共享资源空闲")])]),e._v(" "),r("p",[e._v("将当前请求资源的线程设置为当前工作线程，并将共享资源加锁。")]),e._v(" "),r("ul",[r("li",[e._v("如果被请求的共享资源被占用")])]),e._v(" "),r("p",[e._v("将暂时获取不到锁的线程放入队列中等待解锁时唤醒，这个队列在 AQS 中是一个 CLH 队列。\nAQS 将每个请求资源的线程封装成一个 Node 放入 CLH 队列，实现锁分配。")]),e._v(" "),r("h2",{attrs:{id:"_2-实现原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现原理"}},[e._v("#")]),e._v(" 2. 实现原理")]),e._v(" "),r("h3",{attrs:{id:"_2-1-同步状态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-同步状态"}},[e._v("#")]),e._v(" 2.1 同步状态")]),e._v(" "),r("p",[e._v("AQS 内部使用一个 volatile 修饰的 int 变量表示同步状态：")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("private volatile int state;\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br")])]),r("p",[e._v("有3个方法可以直接操作 state，其他方法都是通过这3个方法间接操作 state：")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 获取当前 state 值，相当于 volatile 读\nprotected final int getState() {\n  return state;\n}\n\n// 设置 state 值，相当于 volatile 写\nprotected final void setState(int newState) {\n  state = newState;\n}\n\n// 使用 CAS 根据 expect 设置 state 的值为 update，相当于原子地 volatile 读+写\nprotected final boolean compareAndSetState(int expect, int update) {\n  return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br"),r("span",{staticClass:"line-number"},[e._v("12")]),r("br"),r("span",{staticClass:"line-number"},[e._v("13")]),r("br"),r("span",{staticClass:"line-number"},[e._v("14")]),r("br")])]),r("h3",{attrs:{id:"_2-2-资源共享方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-资源共享方式"}},[e._v("#")]),e._v(" 2.2 资源共享方式")]),e._v(" "),r("p",[e._v("分为两种：")]),e._v(" "),r("ul",[r("li",[e._v("独占\n同一时间只有一个线程能够使用共享资源，独占锁根据线程竞争方式还可以分为：\n"),r("ul",[r("li",[e._v("公平锁：根据线程在等待队列中的顺序，先到先得。")]),e._v(" "),r("li",[e._v("非公平锁：所有等待线程一起竞争，谁竞争到谁得。")])])]),e._v(" "),r("li",[e._v("共享")])]),e._v(" "),r("p",[e._v("同一时间可以有多个线程访问共享资源，例如 CountDownLatch、Semaphore、CyclicBarrier、ReadWriteLock。\n其实 ReentrantReadWriteLock 是两种混合的，读和读之间是共享的，写和其他操作之间是独占的。")]),e._v(" "),r("h3",{attrs:{id:"_2-3-sync-queue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-sync-queue"}},[e._v("#")]),e._v(" 2.3 Sync queue")]),e._v(" "),r("p",[e._v("AQS 内部的锁队列是一个 CLH，虚拟双向队列，其实存储的不是一个队列整体，而是队列头结点和尾结点，队列关系由 Node 类来维护。\n"),r("img",{attrs:{src:"https://user-images.githubusercontent.com/19852729/124567435-95765700-de76-11eb-836c-970013d17d44.png",alt:"image"}})]),e._v(" "),r("p",[e._v("Node 内部除了封装了等待线程、前驱、后驱结点，还有 waitStatus 和 nextWaiter 结点指针。")]),e._v(" "),r("ul",[r("li",[e._v("waitStatus 表示了当前 Node 的状态，只有以下5种值：\n"),r("ul",[r("li",[r("p",[e._v("SIGNAL(-1)")]),e._v(" "),r("p",[e._v("表示后继结点需要被唤醒。当前结点的后继结点需要 unpark")])]),e._v(" "),r("li",[r("p",[e._v("CANCELLED(1)")]),e._v(" "),r("p",[e._v("结点中的线程已超时或者中断，表示为这个状态的结点不会再改变状态。")])]),e._v(" "),r("li",[r("p",[e._v("CONDITION(-2)")]),e._v(" "),r("p",[e._v("这个状态表示这个 Node 是在一个 Condition 队列中。当有其他线程调用了 Condition 的 signal() 方法后，会从 Condition 队列转移到 Sync 队列。")])]),e._v(" "),r("li",[r("p",[e._v("PROPAGATE(-3)")]),e._v(" "),r("p",[e._v("在 doReleaseShared 中保证 releaseShared 会被传递给其他结点，通常只有 head node 会设置这个状态。")])]),e._v(" "),r("li",[r("p",[e._v("0")]),e._v(" "),r("p",[e._v("表示等待状态，新 Node 进入 Sync 队列时的默认状态。\n可以看出 waitStatus <= 0 时处于正常等待状态，waitStatus > 0 时处于取消状态。")])])])]),e._v(" "),r("li",[e._v("nextWaiter 主要用于有 Condition 存在时，使用这个 nextWaiter 指针组成一个单链表形式的 Condition 队列。")])]),e._v(" "),r("h3",{attrs:{id:"_2-4-conditionobject"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-conditionobject"}},[e._v("#")]),e._v(" 2.4 ConditionObject")]),e._v(" "),r("p",[e._v("ConditionObject 实现了 Condition 接口，主要实现了两个类型的操作，await 操作用于等待 signal，signal 操作用于唤醒等待的线程。\n类的内部维护了一个由 Node 组成的 Condition 队列，说是队列其实是一个记录了头结点和尾结点的单链表。\nCondition 队列中的 Node 的 nextWaiter 指向下一个 Node， 状态为 CONDITION(-2) 或者 CANCELLED(1)。")]),e._v(" "),r("h3",{attrs:{id:"_2-5-核心方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-核心方法"}},[e._v("#")]),e._v(" 2.5 核心方法")]),e._v(" "),r("h4",{attrs:{id:"_2-5-1-独占方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-1-独占方式"}},[e._v("#")]),e._v(" 2.5.1 独占方式")]),e._v(" "),r("ul",[r("li",[e._v("acquire")])]),e._v(" "),r("p",[e._v("以独占模式获取资源，忽略中断。")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public final void acquire(int arg) {\n  if (!tryAcquire(arg) &&\n    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n    selfInterrupt();\n}\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br")])]),r("p",[r("code",[e._v("acquire(int)")]),e._v(" 方法内部逻辑的流程图如下：\n"),r("img",{attrs:{src:"https://user-images.githubusercontent.com/19852729/124858111-09803e80-dfe0-11eb-9d6f-71cc350322d9.png",alt:"acquire"}})]),e._v(" "),r("p",[r("code",[e._v("忽略中断")]),e._v("体现在 "),r("code",[e._v("acquireQueued(Node, int)")]),e._v(" 方法上，如果线程中断，不会立刻响应，会在获取到资源后再返还 false，"),r("code",[e._v("acquire(int)")]),e._v(" 方法收到 false 返还值再调用 interrupt() 方法中断当前线程。\n"),r("code",[e._v("acquireQueued(Node, int)")]),e._v(" 内部是一个无限循环，循环内的逻辑如下：\n"),r("img",{attrs:{src:"https://user-images.githubusercontent.com/19852729/124876144-465a2e80-dffc-11eb-8514-b2aa57a9be33.png",alt:"acquireQueued"}})]),e._v(" "),r("ul",[r("li",[e._v("release")])]),e._v(" "),r("p",[e._v("以独占模式释放资源。")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public final boolean release(int arg) {\n  if (tryRelease(arg)) {\n    Node h = head;\n    if (h != null && h.waitStatus != 0)\n      unparkSuccessor(h);\n    return true;\n  }\n  return false;\n}\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br")])]),r("p",[r("code",[e._v("tryRelease(int)")]),e._v("方法默认实现是直接抛异常，需要依赖子类实现，具体情况具体分析。\n"),r("code",[e._v("unparkSuccessor(Node)")]),e._v("方法的作用就是为了 unpark 传入参数 Node 的后继结点。比如在上面 "),r("code",[e._v("acquire(int)")]),e._v(" 流程中被执行了 park 的节点。")]),e._v(" "),r("h4",{attrs:{id:"_2-5-2-共享方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-2-共享方式"}},[e._v("#")]),e._v(" 2.5.2 共享方式")]),e._v(" "),r("ul",[r("li",[e._v("acquireShared")])]),e._v(" "),r("p",[e._v("以共享模式获取资源。")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public final void acquireShared(int arg) {\n  if (tryAcquireShared(arg) < 0)\n    doAcquireShared(arg);\n}\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br")])]),r("p",[r("code",[e._v("tryAcquireShared(arg)")]),e._v("方法默认实现是直接抛异常，需要依赖子类实现，具体情况具体分析。但是需要注意返回值的定义，"),r("code",[e._v("<0")]),e._v(" 表示失败，"),r("code",[e._v("==0")]),e._v(" 表示成功但是没有剩余许可，"),r("code",[e._v(">0")]),e._v(" 表示成功且还有剩余许可。由此也可以看出当获取许可成功时会直接返回，失败才会进入到 "),r("code",[e._v("doAcquireShared(arg)")]),e._v(" 方法。")]),e._v(" "),r("p",[r("code",[e._v("doAcquireShared(arg)")]),e._v("方法用于将当前线程加入同步队列。内部逻辑和 "),r("code",[e._v("acquireQueued")]),e._v(" 方法类似，区别在于当前结点获取许可成功后会去尝试继续唤醒后继结点。")]),e._v(" "),r("ul",[r("li",[e._v("releaseShared")])]),e._v(" "),r("p",[e._v("以共享模式释放资源。")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public final boolean releaseShared(int arg) {\n  if (tryReleaseShared(arg)) {\n    doReleaseShared();\n    return true;\n  }\n  return false;\n}\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br")])]),r("p",[r("code",[e._v("tryReleaseShared(arg)")]),e._v(" 方法默认实现是直接抛异常，需要依赖子类实现，具体情况具体分析。")]),e._v(" "),r("p",[r("code",[e._v("doReleaseShared()")]),e._v(" 方法用于 unpark 后继结点。")]),e._v(" "),r("h2",{attrs:{id:"_3-实际应用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-实际应用"}},[e._v("#")]),e._v(" 3. 实际应用")]),e._v(" "),r("p",[e._v("java.util.concurrent 包下提供了很多基于 AQS 实现的同步器，日常开发使用这些同步器就够用")]),e._v(" "),r("h3",{attrs:{id:"_3-1-reentrantlock"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-reentrantlock"}},[e._v("#")]),e._v(" 3.1 ReentrantLock")]),e._v(" "),r("ul",[r("li",[e._v("只支持独占方式获取操作")]),e._v(" "),r("li",[e._v("内部实现了两个 AQS，一个公平锁版本，一个非公平锁版本")]),e._v(" "),r("li",[e._v("每个 AQS 都实现了 "),r("code",[e._v("tryAcquire")]),e._v("/"),r("code",[e._v("tryRelease")]),e._v("/"),r("code",[e._v("isHeldExclusively")]),e._v(" 3 个方法")]),e._v(" "),r("li",[e._v("使用了 AQS 父类 "),r("code",[e._v("AbstractOwnableSynchronizer")]),e._v(" 存储当前锁的 owner，便于重入")])]),e._v(" "),r("p",[e._v("ReentrantLock 获取锁的流程如下：")]),e._v(" "),r("p",[r("img",{attrs:{src:t(386),alt:"ReentrantLock"}})]),e._v(" "),r("h3",{attrs:{id:"_3-2-countdownlatch"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-countdownlatch"}},[e._v("#")]),e._v(" 3.2 CountDownLatch")]),e._v(" "),r("ul",[r("li",[e._v("用 state 保存当前计数值")]),e._v(" "),r("li",[r("code",[e._v("countDown")]),e._v(" 方法调用 "),r("code",[e._v("releaseShared(1)")]),e._v("，state 减 1")]),e._v(" "),r("li",[r("code",[e._v("await")]),e._v(" 方法调用 "),r("code",[e._v("acquireSharedInterruptibly(1)")]),e._v("，判断 state 值，等于 0 就返回，否则进入 "),r("code",[e._v("doAcquireSharedInterruptibly")]),e._v(" 方法中循环等待")])]),e._v(" "),r("h3",{attrs:{id:"_3-3-semaphore"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-semaphore"}},[e._v("#")]),e._v(" 3.3 Semaphore")]),e._v(" "),r("ul",[r("li",[e._v("用 state 保存当前许可的数量")]),e._v(" "),r("li",[e._v("内部实现了两个 AQS，一个公平版本，一个非公平版本")]),e._v(" "),r("li",[e._v("每个 AQS 都实现了 "),r("code",[e._v("tryAcquireShared")]),e._v(" 方法，内部使用 "),r("code",[e._v("compareAndSetState")]),e._v(" 方法降低许可数量，返回降低后的许可数量")]),e._v(" "),r("li",[e._v("对外的 "),r("code",[e._v("acquire")]),e._v(" 方法调用了 AQS 的 "),r("code",[e._v("acquireSharedInterruptibly")]),e._v("，当 "),r("code",[e._v("tryAcquireShared")]),e._v(" 方法返回负数时，会进入"),r("code",[e._v("doAcquireSharedInterruptibly")]),e._v(" 方法中循环等待，这就对应许可数量不够而调用 "),r("code",[e._v("acquire")]),e._v(" 方法的线程会阻塞")])]),e._v(" "),r("h3",{attrs:{id:"_3-4-cyclicbarrier"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-cyclicbarrier"}},[e._v("#")]),e._v(" 3.4 CyclicBarrier")]),e._v(" "),r("ul",[r("li",[e._v("内部包含了一个 "),r("code",[e._v("ReentrantLock")]),e._v(" 和一个 "),r("code",[e._v("Condition")]),e._v("，这两个同步器的底层实现都是 AQS")]),e._v(" "),r("li",[r("code",[e._v("CyclicBarrier")]),e._v(" 触发执行后或者调用 "),r("code",[e._v("breakBarrier")]),e._v(" 破坏屏障后，"),r("code",[e._v("CyclicBarrier")]),e._v(" 都会恢复初始的可用状态，重新接受 "),r("code",[e._v("await")])]),e._v(" "),r("li",[e._v("当某次 "),r("code",[e._v("await")]),e._v(" 进入后，index 为 0，则用当前线程执行 "),r("code",[e._v("barrierAction")]),e._v("，然后调用 "),r("code",[e._v("nextGeneration")]),e._v(" 唤醒等待在 "),r("code",[e._v("Condition")]),e._v(" 上的所有线程并重置 "),r("code",[e._v("CyclicBarrier")]),e._v(" 状态")])]),e._v(" "),r("p",[r("code",[e._v("dowait")]),e._v(" 流程：")]),e._v(" "),r("p",[r("img",{attrs:{src:t(387),alt:"CyclicBarrier"}})]),e._v(" "),r("h2",{attrs:{id:"_4-自定义同步器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-自定义同步器"}},[e._v("#")]),e._v(" 4. 自定义同步器")]),e._v(" "),r("p",[e._v("AQS 采用"),r("strong",[e._v("模板方法")]),e._v("模式设计，acquire()/release() 等 public 方法都是 final 的，对子类开放了一些 protected 方法，供子类修改实现。")]),e._v(" "),r("ul",[r("li",[e._v("tryAcquire(int)\n独占方式，尝试获取资源，成功返回 true，失败返回 false。")]),e._v(" "),r("li",[e._v("tryRelease(int)\n独占方式，尝试释放资源，成功返回 true，失败返回 false。")]),e._v(" "),r("li",[e._v("tryAcquireShared(int)\n共享方式，尝试获取资源，失败返回负数，成功但没有剩余可用资源返回 0，成功且仍有剩余可用资源返回正数。")]),e._v(" "),r("li",[e._v("tryReleaseShared(int)\n共享方式，尝试释放资源，成功返回 true，失败返回 false。")]),e._v(" "),r("li",[e._v("isHeldExclusively()\n判断当前线程是否正在独占资源。用到 Condition 时才会重写这个方法。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);