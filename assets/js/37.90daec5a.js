(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{405:function(t,_,v){"use strict";v.r(_);var a=v(44),s=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"背包问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#背包问题"}},[t._v("#")]),t._v(" 背包问题")]),t._v(" "),v("h2",{attrs:{id:"_1-0-1-背包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-0-1-背包"}},[t._v("#")]),t._v(" 1. 0-1 背包")]),t._v(" "),v("p",[v("strong",[t._v("0-1 背包依赖的是「上一行正上方的格子」和「上一行左边的格子」")])]),t._v(" "),v("p",[t._v("所以内层用倒序迭代，要计算本格时，保证本格左侧都是上一次迭代的数据。")]),t._v(" "),v("h2",{attrs:{id:"_2-完全背包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-完全背包"}},[t._v("#")]),t._v(" 2. 完全背包")]),t._v(" "),v("p",[v("strong",[t._v("完全背包依赖的是「上一行正上方的格子」和「本行左边的格子」")])]),t._v(" "),v("p",[t._v("所以内层用正序迭代，要计算本格时，保证本轮迭代中本格左侧的都已经计算完成。")]),t._v(" "),v("h2",{attrs:{id:"_3-多重背包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-多重背包"}},[t._v("#")]),t._v(" 3. 多重背包")]),t._v(" "),v("p",[t._v("多重背包可以通过枚举每件物品的价值和体积，转换为 0-1 背包问题。转换成 0-1 背包可以更清晰的理解转移方程，但是不会降低复杂度。")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("一维优化")]),t._v(" "),v("p",[t._v("可以通过一维解法降低多重背包的空间复杂度，但是"),v("strong",[t._v("无法")]),t._v("降低时间复杂度。因为一维数组中无法获取当前结果到底使用了某个物品多少次，剩余的次数也无法判断，因此只能通过3层循环来求解。")]),t._v(" "),v("ul",[v("li",[t._v("优化思路和 0-1 背包一样，所以内层用倒序迭代，要计算本格时，保证本格左侧都是上一次迭代的数据。")])])]),t._v(" "),v("li",[v("p",[t._v("二进制压缩优化")])]),t._v(" "),v("li",[v("p",[t._v("单调队列优化")])])]),t._v(" "),v("h2",{attrs:{id:"_4-混合背包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-混合背包"}},[t._v("#")]),t._v(" 4. 混合背包")]),t._v(" "),v("p",[t._v("混合背包中的物品同时具有 0-1、完全、多重背包的特性，即部分物品可以取有限次，部分物品可以取无限次，部分物品只能取1次。")]),t._v(" "),v("p",[t._v("解题思路其实就是在遍历当前物品时根据属性选择对应背包问题的迭代方式。如：")]),t._v(" "),v("ul",[v("li",[t._v("只能取 1 次和有限次，就正向遍历。")]),t._v(" "),v("li",[t._v("能取无限次，就反向遍历。")])])])}),[],!1,null,null,null);_.default=s.exports}}]);