(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{381:function(t,_,v){"use strict";v.r(_);var e=v(44),a=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"计数排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计数排序"}},[t._v("#")]),t._v(" 计数排序")]),t._v(" "),v("p",[t._v("计数排序（Counting Sort）是一种基于"),v("code",[t._v("非比较")]),t._v("的具有线性时间复杂度的排序算法。")]),t._v(" "),v("p",[t._v("计数排序高效的前提是元素的值域（基数）较小。")]),t._v(" "),v("h2",{attrs:{id:"_1-工作原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-工作原理"}},[t._v("#")]),t._v(" 1. 工作原理")]),t._v(" "),v("p",[t._v("使用一个额外的数组 "),v("code",[t._v("C[i]")]),t._v("，其中第 i 个元素是待排序序列中排序值等于 i 的个数。")]),t._v(" "),v("p",[t._v("工作流程大致分为以下3步：")]),t._v(" "),v("ul",[v("li",[t._v("遍历序列，计数每个元素出现的次数，放入数组 "),v("code",[t._v("C[i]")])]),t._v(" "),v("li",[t._v("遍历数组 "),v("code",[t._v("C[i]")]),t._v("，计算前缀和。")]),t._v(" "),v("li",[t._v("根据前缀和，遍历原序列重新构造一个数组")])]),t._v(" "),v("p",[t._v("如果原序列中的元素本身就是整形，后两步可以简化为直接按出现次数输出一个新的整形序列，不需要计算前缀和。")]),t._v(" "),v("h2",{attrs:{id:"_2-性质"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-性质"}},[t._v("#")]),t._v(" 2. 性质")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("性质")]),t._v(" "),v("th"),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("稳定性")]),t._v(" "),v("td",[t._v("稳定")]),t._v(" "),v("td",[t._v("稳定性来自于工作流程的第三步，输出最终排序序列时还是会按原序列的相对顺序遍历一遍，用前缀和确定相同一组元素的起始位置，但是一组相同元素内部的相对位置没有变化")])]),t._v(" "),v("tr",[v("td",[t._v("最坏时间复杂度")]),t._v(" "),v("td",[t._v("O(n + w)")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("最好时间复杂度")]),t._v(" "),v("td",[t._v("O(n + w)")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("平均时间复杂度")]),t._v(" "),v("td",[t._v("O(n + w)")]),t._v(" "),v("td",[t._v("w是值域大小，各需遍历原序列和值域数组有限次数")])]),t._v(" "),v("tr",[v("td",[t._v("空间复杂度")]),t._v(" "),v("td",[t._v("O(n + w)")]),t._v(" "),v("td",[t._v("需要一个和原序列大小相同的新序列，以及一个满足值域大小（w）的数组用于计数")])])])]),t._v(" "),v("h2",{attrs:{id:"_3-伪代码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-伪代码"}},[t._v("#")]),t._v(" 3. 伪代码")]),t._v(" "),v("p",[t._v("通用场景：")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code")]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"})]),v("p",[t._v("整形序列场景：")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code")]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"})]),v("h2",{attrs:{id:"_4-优化细节"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-优化细节"}},[t._v("#")]),t._v(" 4. 优化细节")]),t._v(" "),v("ul",[v("li",[t._v("第一遍遍历时可以记录最小值和最大值，并将最小值作为数组的起点，相对 index 为 0，方便构造尽可能小的计数数组。")])]),t._v(" "),v("h2",{attrs:{id:"_5-实例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-实例"}},[t._v("#")]),t._v(" 5. 实例")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://leetcode-cn.com/problems/h-index/",target:"_blank",rel:"noopener noreferrer"}},[t._v("274.H 指数"),v("OutboundLink")],1),t._v(" ，没有实际排序，只是用到了计数排序的思想")]),t._v(" "),v("li",[v("a",{attrs:{href:"https://leetcode-cn.com/problems/sort-an-array/",target:"_blank",rel:"noopener noreferrer"}},[t._v("912.排序数组"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=a.exports}}]);