(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{400:function(t,a,s){"use strict";s.r(a);var _=s(44),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"基数排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基数排序"}},[t._v("#")]),t._v(" 基数排序")]),t._v(" "),s("p",[t._v("基数排序（Radix Sort）是一种"),s("strong",[t._v("非比较型")]),t._v("排序算法。")]),t._v(" "),s("p",[t._v("最早用于解决卡片排序问题，主要思想是拆分元素，分开排序。")]),t._v(" "),s("h2",{attrs:{id:"_1-工作原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-工作原理"}},[t._v("#")]),t._v(" 1. 工作原理")]),t._v(" "),s("p",[t._v("将待排序的元素拆分为 "),s("code",[t._v("k")]),t._v(" 个关键字，依次对第 "),s("code",[t._v("k")]),t._v(" 个、"),s("code",[t._v("k-1")]),t._v(" 个、"),s("code",[t._v("k-2")]),t._v(" 个、..."),s("code",[t._v("1")]),t._v(" 个关键字进行"),s("code",[t._v("稳定排序")]),t._v("（任何一种其他的稳定排序算法）。")]),t._v(" "),s("p",[t._v("虽然也要使用其他的稳定排序算法，但是依据拆分关键字的效果，可以显著减少外层排序的循环次数，通常比基于比较的排序算法要快。")]),t._v(" "),s("h2",{attrs:{id:"_2-性质"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-性质"}},[t._v("#")]),t._v(" 2.性质")]),t._v(" "),s("p",[t._v("用 "),s("code",[t._v("r")]),t._v(" 代表关键字基数，"),s("code",[t._v("n")]),t._v(" 代表序列长度，"),s("code",[t._v("c")]),t._v("代表关键字个数。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("性质")]),t._v(" "),s("th"),t._v(" "),s("th",[t._v("描述")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("稳定性")]),t._v(" "),s("td",[t._v("稳定")]),t._v(" "),s("td",[t._v("取决于内层排序，内层排序为稳定")])]),t._v(" "),s("tr",[s("td",[t._v("最坏时间复杂度")]),t._v(" "),s("td",[t._v("O(n(r + c))")]),t._v(" "),s("td",[t._v("基数排序时间复杂度取决于内层排序算法，这里仅供参考")])]),t._v(" "),s("tr",[s("td",[t._v("最好时间复杂度")]),t._v(" "),s("td",[t._v("O(n(r + c))")]),t._v(" "),s("td",[t._v("基数排序时间复杂度取决于内层排序算法，这里仅供参考")])]),t._v(" "),s("tr",[s("td",[t._v("平均时间复杂度")]),t._v(" "),s("td",[t._v("O(n(r + c))")]),t._v(" "),s("td",[t._v("基数排序时间复杂度取决于内层排序算法，这里仅供参考")])]),t._v(" "),s("tr",[s("td",[t._v("空间复杂度")]),t._v(" "),s("td",[t._v("O(c + rn)")]),t._v(" "),s("td",[t._v("额外空间取决于关键字拆分的数量")])])])]),t._v(" "),s("h2",{attrs:{id:"_3-伪代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-伪代码"}},[t._v("#")]),t._v(" 3. 伪代码")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Input:一个包含n个可排序元素的序列 A[n]，将每个元素拆分为 k 个关键字。\nOutput:把输入序列按非递减排序的序列 A[n]。\nMethod:\nfor i <- k down to 1\n  对第 i 个关键字使用内层排序 \n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("h2",{attrs:{id:"_4-java-实现-以十进制整数为例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-java-实现-以十进制整数为例"}},[t._v("#")]),t._v(" 4. Java 实现，以十进制整数为例")]),t._v(" "),s("p",[t._v("十进制整数的关键字基数为 10，内层可以使用计数排序")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("public static radixSort(int[] source){\n  int max = Arrays.stream().max().getAsInt();\n  // 按进制划分每次内层排序\n  for(int i = 1; max / i > 0; i *= 10){\n    countingSort(source, i);  // 内层排序时把每个元素除以 i，做计数排序\n  }\n}\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])])])}),[],!1,null,null,null);a.default=v.exports}}]);