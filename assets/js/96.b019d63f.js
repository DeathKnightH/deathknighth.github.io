(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{480:function(a,t,e){"use strict";e.r(t);var _=e(44),v=Object(_.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"default-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#default-方法"}},[a._v("#")]),a._v(" Default 方法")]),a._v(" "),e("h2",{attrs:{id:"_1-概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念"}},[a._v("#")]),a._v(" 1. 概念")]),a._v(" "),e("p",[a._v("Java 8 之前的 Interface 是不能有方法实现的，所有方法只能是 "),e("code",[a._v("public abstract")]),a._v("，只能让接口的实现类来实现这些方法，这是一个面向对象的常用设计思路。")]),a._v(" "),e("p",[a._v("但是这个思路在实际开发时有一个问题，接口修改的开销很大，需要修改该接口所有的实现类，这在 Java 8 之前有一种解决方案，先用一个抽象类实现这个接口，提供一些默认方法实现，再由其他实现类继承抽象类。但是\n这也抛弃了接口一部分灵活性，毕竟 Java 只能单继承，却能实现多个接口。")]),a._v(" "),e("p",[a._v("Java 8 用 Default 方法来尝试解决这个问题，让 Interface 中能存在 Default 方法，这样在修改老接口时，可以新增 "),e("code",[a._v("default")]),a._v(" 修饰的有默认实现的方法，这样实现类就不用一一修改了。")]),a._v(" "),e("h2",{attrs:{id:"_2-default-方法多重继承的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-default-方法多重继承的问题"}},[a._v("#")]),a._v(" 2.default 方法多重继承的问题")]),a._v(" "),e("p",[a._v("一个类是能实现多个接口的，那么不同接口里的 "),e("code",[a._v("default")]),a._v(" 方法可能会产生冲突。")]),a._v(" "),e("p",[a._v("Java 8 对这种冲突有一个固定的优先级判断规则：")]),a._v(" "),e("ul",[e("li",[a._v("当前实现类中的相同方法优先级最高")]),a._v(" "),e("li",[a._v("如果当前实现类没有实现此方法，则选择继承路径最短的 default 方法")]),a._v(" "),e("li",[a._v("如果继承路径都一样，那么会报错 Duplicate default methods，此时如果一定要使用接口的 default 方法，可以用类名加 super 关键字来使用，例如调用 "),e("code",[a._v("InterfaceName.super.defaultMethodName()")])])]),a._v(" "),e("h2",{attrs:{id:"_3-好处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-好处"}},[a._v("#")]),a._v(" 3. 好处")]),a._v(" "),e("ul",[e("li",[a._v("兼容老代码，在接口中开发新的方法。")]),a._v(" "),e("li",[a._v("配合新增的 lambda 表达式，提供更强大的接口功能。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);