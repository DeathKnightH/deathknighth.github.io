(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{494:function(t,a,_){"use strict";_.r(a);var v=_(44),r=Object(v.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"locksupport"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#locksupport"}},[t._v("#")]),t._v(" LockSupport")]),t._v(" "),_("p",[_("code",[t._v("LockSupport")]),t._v(" 用来创建锁和其他同步类的基本"),_("strong",[t._v("线程阻塞原语")]),t._v("。")]),t._v(" "),_("p",[t._v("具体而言，调用 "),_("code",[t._v("LockSupport.park")]),t._v(" 方法会阻塞当前线程。调用 "),_("code",[t._v("LockSupport.unpark")]),t._v(" 并传入阻塞线程作为参数，可以唤醒阻塞的线程。")]),t._v(" "),_("h2",{attrs:{id:"_1-实现细节分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-实现细节分析"}},[t._v("#")]),t._v(" 1. 实现细节分析")]),t._v(" "),_("h3",{attrs:{id:"_1-1-静态属性和构造函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-静态属性和构造函数"}},[t._v("#")]),t._v(" 1.1 静态属性和构造函数")]),t._v(" "),_("p",[_("code",[t._v("LockSupport")]),t._v(" 内部存储了 "),_("code",[t._v("Thread")]),t._v(" 类中几个关键属性的偏移地址和一个 Unsafe 类引用:")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("  private static final sun.misc.Unsafe UNSAFE;  // Unsafe 类引用\n  private static final long parkBlockerOffset;  // Thread 类中 parkBlocker 字段的偏移地址\n  private static final long SEED;               // Thread 类中 threadLocalRandomSeed 字段的偏移地址\n  private static final long PROBE;              // Thread 类中 threadLocalRandomProbe 字段的偏移地址\n  private static final long SECONDARY;          // Thread 类中 threadLocalRandomSecondarySeed 字段的偏移地址\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br")])]),_("p",[t._v("构造函数为 "),_("code",[t._v("private")]),t._v(" 修饰，且内部没有调用。\n对外开放的方法均为 "),_("code",[t._v("static")]),t._v(" 方法，一般使用时不会创建 "),_("code",[t._v("LockSupport")]),t._v(" 对象，直接通过类名使用 static 方法。")]),t._v(" "),_("h3",{attrs:{id:"_1-2-park"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-park"}},[t._v("#")]),t._v(" 1.2 park")]),t._v(" "),_("p",[t._v("park 方法有很多变种，用于实现不同场景的 park 功能，但是 park 功能本身还是依赖于 "),_("code",[t._v("Unsafe.park")]),t._v("。")]),t._v(" "),_("p",[t._v("调用 "),_("code",[t._v("Unsafe.park")]),t._v(" 后会阻塞当前线程，直到以下情况之一发生：")]),t._v(" "),_("ul",[_("li",[t._v("调用了 "),_("code",[t._v("unpark")]),t._v(" 函数，释放了该线程的许可。")]),t._v(" "),_("li",[t._v("该线程被中断。")]),t._v(" "),_("li",[t._v("park 设置的限制时间到了。")])]),t._v(" "),_("p",[t._v("需要注意这里是阻塞线程，而不是挂起线程，实际效果和 Thread.sleep() 方法类似。")]),t._v(" "),_("h4",{attrs:{id:"_1-2-1-park-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-park-方法"}},[t._v("#")]),t._v(" 1.2.1 park 方法")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("public static void park();  // 直接调用 Unsafe.park(false, 0L)\n\npublic static void park(Object blocker);  // 调用 Unsafe.park(false, 0L) 之前先把 blocker 设置到当前线程的 parkBlocker 字段\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br")])]),_("h4",{attrs:{id:"_1-2-2-parknanos-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-2-parknanos-方法"}},[t._v("#")]),t._v(" 1.2.2 parkNanos 方法")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("public static void parkNanos(Object blocker, long nanos); // 调用 Unsafe.park(false, nanos) 之前先把 blocker 设置到当前线程的 parkBlocker 字段\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br")])]),_("p",[t._v("额外传入一个等待时间，等待时间完会自动解除阻塞。")]),t._v(" "),_("h4",{attrs:{id:"_1-2-3-parkuntil-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-parkuntil-方法"}},[t._v("#")]),t._v(" 1.2.3 parkUntil 方法")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("public static void parkUntil(Object blocker, long deadline);  // 调用 Unsafe.park(true, deadline) 之前先把 blocker 设置到当前线程的 parkBlocker 字段\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br")])]),_("p",[t._v("额外传入一个指定的时间点，到了指定时间点会自动解除阻塞。")]),t._v(" "),_("h3",{attrs:{id:"_1-3-unpark"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-unpark"}},[t._v("#")]),t._v(" 1.3 unpark")]),t._v(" "),_("p",[t._v("从方法声明上看：")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("public static void unpark(Thread thread);\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br")])]),_("p",[t._v("需要传入指定线程作为参数，如果线程正被 park，则解除阻塞状态；否则让下一次 park 失效。")]),t._v(" "),_("p",[t._v("如果线程还没有启动，不保证有任何效果。")]),t._v(" "),_("h2",{attrs:{id:"_2-使用示例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用示例"}},[t._v("#")]),t._v(" 2. 使用示例")]),t._v(" "),_("h3",{attrs:{id:"_2-1-使用-park-unpark-实现线程同步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-使用-park-unpark-实现线程同步"}},[t._v("#")]),t._v(" 2.1 使用 park/unpark 实现线程同步")]),t._v(" "),_("h3",{attrs:{id:"_2-2-中断响应"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-中断响应"}},[t._v("#")]),t._v(" 2.2 中断响应")]),t._v(" "),_("p",[t._v("中断线程后，会退出阻塞。即当线程设置为 interrupt 后会退出阻塞，效果和调用 unpark() 一致。")]),t._v(" "),_("h2",{attrs:{id:"_3-wait-notify-、park-unpark-、sleep-比较"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-wait-notify-、park-unpark-、sleep-比较"}},[t._v("#")]),t._v(" 3. wait()/notify()、park()/unpark()、sleep() 比较")]),t._v(" "),_("h3",{attrs:{id:"_3-1-阻塞-挂起"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-阻塞-挂起"}},[t._v("#")]),t._v(" 3.1 阻塞/挂起")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("方法")]),t._v(" "),_("th",[t._v("线程操作")]),t._v(" "),_("th",[t._v("是否释放锁")]),t._v(" "),_("th",[t._v("方法所属类/接口")]),t._v(" "),_("th",[t._v("参数")]),t._v(" "),_("th",[t._v("使用限制")]),t._v(" "),_("th",[t._v("异常")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("wait()")]),t._v(" "),_("td",[t._v("挂起当前线程")]),t._v(" "),_("td",[t._v("是")]),t._v(" "),_("td",[t._v("属于 Object 类，即 java 所有对象都有这个方法")]),t._v(" "),_("td",[t._v("1.不带参数，需要手动调用 notify() 唤醒 2.带时间参数，可以超时自动唤醒")]),t._v(" "),_("td",[t._v("只能在同步块中使用")]),t._v(" "),_("td",[t._v("抛出 InterruptedException")])]),t._v(" "),_("tr",[_("td",[t._v("park()")]),t._v(" "),_("td",[t._v("阻塞当前线程")]),t._v(" "),_("td",[t._v("否")]),t._v(" "),_("td",[t._v("属于 LockSupport 类，但是因为是public static 方法，所以可以在任何类中使用")]),t._v(" "),_("td",[t._v("1.不带参数 2.带 blocker 参数")]),t._v(" "),_("td",[t._v("无限制，任何地方都能使用")]),t._v(" "),_("td",[t._v("无")])]),t._v(" "),_("tr",[_("td",[t._v("parkNanos()")]),t._v(" "),_("td",[t._v("阻塞当前线程")]),t._v(" "),_("td",[t._v("否")]),t._v(" "),_("td",[t._v("属于 LockSupport 类，是 park() 方法的带超时时间版本")]),t._v(" "),_("td",[t._v("两个参数，blocker 对象和超时时间(ns)")]),t._v(" "),_("td",[t._v("无限制，任何地方都能使用")]),t._v(" "),_("td",[t._v("无")])]),t._v(" "),_("tr",[_("td",[t._v("parkUntil()")]),t._v(" "),_("td",[t._v("阻塞当前线程")]),t._v(" "),_("td",[t._v("否")]),t._v(" "),_("td",[t._v("属于 LockSupport 类，是 park() 方法的带指定时间版本")]),t._v(" "),_("td",[t._v("两个参数，blocker 对象和指定唤醒时间(ns)")]),t._v(" "),_("td",[t._v("无限制，任何地方都能使用")]),t._v(" "),_("td",[t._v("无")])]),t._v(" "),_("tr",[_("td",[t._v("sleep()")]),t._v(" "),_("td",[t._v("阻塞指定线程")]),t._v(" "),_("td",[t._v("否")]),t._v(" "),_("td",[t._v("属于 Thread 类，如果阻塞当前线程直接调用即可")]),t._v(" "),_("td",[t._v("必须至少带一个参数，超时时间(millis)，或者额外加第二个参数，更小单位的超时时间(ns)")]),t._v(" "),_("td",[t._v("只能对 Thread 对象使用")]),t._v(" "),_("td",[t._v("抛出 InterruptedException")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-2-唤醒"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-唤醒"}},[t._v("#")]),t._v(" 3.2 唤醒")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("方法")]),t._v(" "),_("th",[t._v("线程操作")]),t._v(" "),_("th",[t._v("特性")]),t._v(" "),_("th",[t._v("方法所属类/接口")]),t._v(" "),_("th",[t._v("参数")]),t._v(" "),_("th",[t._v("使用限制")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("notify()")]),t._v(" "),_("td",[t._v("唤醒挂起在指定 Object 上的线程")]),t._v(" "),_("td",[t._v("如果挂起的有多个线程，那么随机唤醒一个")]),t._v(" "),_("td",[t._v("Object 类")]),t._v(" "),_("td",[t._v("不带参数")]),t._v(" "),_("td",[t._v("需要在 wait() 之后执行，否则会抛出 IllegalMonitorStateException")])]),t._v(" "),_("tr",[_("td",[t._v("notifyAll()")]),t._v(" "),_("td",[t._v("唤醒挂起在指定 Object 上的所有线程")]),t._v(" "),_("td",[t._v("唤醒所有挂起在 Object 上的所有线程")]),t._v(" "),_("td",[t._v("Object 类")]),t._v(" "),_("td",[t._v("不带参数")]),t._v(" "),_("td",[t._v("需要在 wait() 之后执行，否则会抛出 IllegalMonitorStateException")])]),t._v(" "),_("tr",[_("td",[t._v("unpark()")]),t._v(" "),_("td",[t._v("使指定线程许可可用")]),t._v(" "),_("td",[t._v("如果指定线程在 park 状态则取消阻塞状态，如果指定线程不在 park 状态则使下一次该线程的 park() 调用不会阻塞线程")]),t._v(" "),_("td",[t._v("LockSupport 类")]),t._v(" "),_("td",[t._v("参数为需要 unpark 的线程对象")]),t._v(" "),_("td",[t._v("无限制，但如果线程未启动，则 unpark() 不会生效")])])])])])}),[],!1,null,null,null);a.default=r.exports}}]);