(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{377:function(a,e,t){"use strict";t.r(e);var s=t(44),r=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"happens-before-原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#happens-before-原则"}},[a._v("#")]),a._v(" Happens-Before 原则")]),a._v(" "),t("p",[a._v("为保证程序有序性，JVM 定义了 Happens-Before 原则。")]),a._v(" "),t("p",[a._v("要特别注意，这里的有序性并不是实际执行的时间顺序，而是前面操作产生的结果对于后面的操作可见。")]),a._v(" "),t("h2",{attrs:{id:"_1-八大原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-八大原则"}},[a._v("#")]),a._v(" 1. 八大原则")]),a._v(" "),t("h3",{attrs:{id:"_1-1-single-thread-单一线程原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-single-thread-单一线程原则"}},[a._v("#")]),a._v(" 1.1 Single Thread (单一线程原则)")]),a._v(" "),t("p",[a._v("在一个线程内，在程序中前面的操作 "),t("code",[a._v("happens-before")]),a._v(" 于后面的操作。")]),a._v(" "),t("p",[a._v("需要特别注意这里有序的是执行结果，如果两个语句没有任何关联，有可能发生指令重排，这时实际执行顺序不一定是代码书写顺序。比如在一个线程内：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("int a = 5; // 1\nint b = 6; // 2\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("p",[a._v("最终的结果肯定是 "),t("code",[a._v("a")]),a._v(" 被赋值为 5，"),t("code",[a._v("b")]),a._v(" 被赋值为 6。但是实际执行顺序不一定是先 1 后 2，可能是先 2 后 1。再看一个例子：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("int a = 5;     // 1\nint b = a + 1; // 2\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("p",[a._v("最终结果也是 "),t("code",[a._v("a")]),a._v(" 被赋值为 5，"),t("code",[a._v("b")]),a._v(" 被赋值为 6。因为 1 的执行结果要对 2 可见，所以这里 1 一定是先于 2 实际执行的。")]),a._v(" "),t("p",[a._v("JVM在单个线程内部要维护类似严格串行的语义，如果多个操作之间有先后依赖关系，则不允许对这些操作进行重排序。")]),a._v(" "),t("h3",{attrs:{id:"_1-2-monitor-lock-管程锁定原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-monitor-lock-管程锁定原则"}},[a._v("#")]),a._v(" 1.2 Monitor Lock (管程锁定原则)")]),a._v(" "),t("p",[a._v("对一个锁的 unlock 操作 "),t("code",[a._v("happens-before")]),a._v(" 于后续对同一个锁的 lock 操作。")]),a._v(" "),t("h3",{attrs:{id:"_1-3-volatile-variable-volatile-变量原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-volatile-variable-volatile-变量原则"}},[a._v("#")]),a._v(" 1.3 Volatile Variable (volatile 变量原则)")]),a._v(" "),t("p",[a._v("对一个 volatile 变量的写操作 "),t("code",[a._v("happens-before")]),a._v(" 于后续对这个变量的读操作。")]),a._v(" "),t("h3",{attrs:{id:"_1-4-thread-start-线程启动原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-thread-start-线程启动原则"}},[a._v("#")]),a._v(" 1.4 Thread Start (线程启动原则)")]),a._v(" "),t("p",[a._v("Thread 对象的 start() 方法调用 "),t("code",[a._v("happens-before")]),a._v(" 于任何发生在这个 Thread 内的操作。")]),a._v(" "),t("p",[a._v("把调用 start() 的线程视为主线程，主线程在 start() 方法调用前的操作结果对 Thread 对象都是可见的。")]),a._v(" "),t("h3",{attrs:{id:"_1-5-thread-termination-线程终止原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-thread-termination-线程终止原则"}},[a._v("#")]),a._v(" 1.5 Thread Termination (线程终止原则)")]),a._v(" "),t("p",[a._v("Thread 对象内的任何操作都 "),t("code",[a._v("happens-before")]),a._v(" 于对同一个 Thread 的终止检测。")]),a._v(" "),t("p",[a._v("如何算终止检测？")]),a._v(" "),t("ul",[t("li",[a._v("Thread.join() 方法返回。")]),a._v(" "),t("li",[a._v("Thread.isAlive() 返回 false。")])]),a._v(" "),t("h3",{attrs:{id:"_1-6-thread-interruption-线程中断原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-thread-interruption-线程中断原则"}},[a._v("#")]),a._v(" 1.6 Thread Interruption (线程中断原则)")]),a._v(" "),t("p",[a._v("调用 Thread 对象的 interrupt() 方法 "),t("code",[a._v("happens-before")]),a._v(" 于该 Thread 对象的代码检测到中断事件发生。")]),a._v(" "),t("p",[a._v("如何算检测到中断事件发生？")]),a._v(" "),t("ul",[t("li",[a._v("抛出 InterruptedException")]),a._v(" "),t("li",[a._v("调用 interrupted() 方法")]),a._v(" "),t("li",[a._v("调用 isInterrupted() 方法")])]),a._v(" "),t("h3",{attrs:{id:"_1-7-finalizer-对象终结原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-finalizer-对象终结原则"}},[a._v("#")]),a._v(" 1.7 Finalizer (对象终结原则)")]),a._v(" "),t("p",[a._v("对象的初始化完成（构造函数执行结束） "),t("code",[a._v("happens-before")]),a._v(" 于同一个对象的 finalize() 方法调用。")]),a._v(" "),t("h3",{attrs:{id:"_1-8-transitivity-传递性原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-8-transitivity-传递性原则"}},[a._v("#")]),a._v(" 1.8 Transitivity (传递性原则)")]),a._v(" "),t("p",[a._v("以上 "),t("code",[a._v("happens-before")]),a._v(" 原则具有传递性，如有3个操作 A、B、C，根据以上原则判断有 A "),t("code",[a._v("happens-before")]),a._v(" B，且 B "),t("code",[a._v("happens-before")]),a._v(" C，则一定有 A "),t("code",[a._v("happens-before")]),a._v(" C。")]),a._v(" "),t("h2",{attrs:{id:"_2-实例分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-实例分析"}},[a._v("#")]),a._v(" 2. 实例分析")]),a._v(" "),t("p",[a._v("分别有3个线程 A/B/C 执行3个方法。")]),a._v(" "),t("p",[a._v("A 线程执行 "),t("code",[a._v("methodA")]),a._v("，B 线程执行 "),t("code",[a._v("methodB")]),a._v("， C 线程执行 "),t("code",[a._v("methodC")]),a._v(" 。")]),a._v(" "),t("p",[a._v("且 3 个线程的执行顺序为 A -> B -> C")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("private volatile int value = 0;\nprivate int a = 0;\nprivate int b = 0;\n\npublic void methodA(int value){\n  this.value = 1;           // 1\n  synchronized(this){\n    b = a + 2;              // 2\n  }\n}\n\npublic void methodB(){\n  synchronized(this){\n    int temp = this.value;  // 3 \n  }\n  this.value = b + 3;       // 4\n}\n\npublic void methodC(){\n  int c = value + a;        // 5\n}\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br"),t("span",{staticClass:"line-number"},[a._v("16")]),t("br"),t("span",{staticClass:"line-number"},[a._v("17")]),t("br"),t("span",{staticClass:"line-number"},[a._v("18")]),t("br"),t("span",{staticClass:"line-number"},[a._v("19")]),t("br"),t("span",{staticClass:"line-number"},[a._v("20")]),t("br"),t("span",{staticClass:"line-number"},[a._v("21")]),t("br")])]),t("p",[a._v("那么执行结果的可见顺序为 1 -> 2 -> 3 -> 4 -> 5")]),a._v(" "),t("p",[a._v("分析如下：")]),a._v(" "),t("ul",[t("li",[a._v("1 -> 2 和 3 -> 4 顺序根据单一线程原则。")]),a._v(" "),t("li",[a._v("4 -> 5 顺序根据volatile 变量原则。")]),a._v(" "),t("li",[a._v("2 -> 3 顺序根据管程锁定原则。")]),a._v(" "),t("li",[a._v("最后根据传递性可以把以上3条连接起来，最终得出 1 -> 2 -> 3 -> 4 -> 5")])])])}),[],!1,null,null,null);e.default=r.exports}}]);