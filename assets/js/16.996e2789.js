(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{364:function(_,t,a){_.exports=a.p+"assets/img/factorymethod.drawio.c4e07da4.png"},440:function(_,t,a){"use strict";a.r(t);var v=a(44),r=Object(v.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"工厂方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#工厂方法"}},[_._v("#")]),_._v(" 工厂方法")]),_._v(" "),v("h2",{attrs:{id:"_1-概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念"}},[_._v("#")]),_._v(" 1. 概念")]),_._v(" "),v("p",[_._v("工厂方法（Factory Method）又称虚拟构造函数，是一种"),v("code",[_._v("创建型模式")]),_._v("。")]),_._v(" "),v("h2",{attrs:{id:"_2-意图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-意图"}},[_._v("#")]),_._v(" 2. 意图")]),_._v(" "),v("p",[_._v("在父类中提供一个创建对象的接口，由子类决定创建什么类型的对象，即把实例化推迟到子类进行。")]),_._v(" "),v("h2",{attrs:{id:"_3-类图示例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-类图示例"}},[_._v("#")]),_._v(" 3. 类图示例")]),_._v(" "),v("p",[v("img",{attrs:{src:a(364),alt:"FactoryMethod"}})]),_._v(" "),v("p",[_._v("如图所示：")]),_._v(" "),v("ul",[v("li",[_._v("Product：产品类的顶层接口，是工厂方法的返回类型，其中定义了所有业务相关的操作接口，供 "),v("code",[_._v("Creator")]),_._v(" 业务逻辑使用。")]),_._v(" "),v("li",[_._v("Concrete Products：具体的产品类实现。")]),_._v(" "),v("li",[v("strong",[_._v("Creator")]),_._v("：\n"),v("ul",[v("li",[_._v("工厂方法声明的地方，图中 "),v("code",[_._v("createProduct()")]),_._v(" 方法就是工厂方法，这个方法通常是 "),v("code",[_._v("abstract")]),_._v(" 的，返回的类型必须是 "),v("code",[_._v("Product")]),_._v(" 的顶层接口类型。")]),_._v(" "),v("li",[v("code",[_._v("Creator")]),_._v(" 本身一般不负责创建 "),v("code",[_._v("Product")]),_._v("，而是由 "),v("code",[_._v("Creator")]),_._v(" 的不同子类通过实现不同的 "),v("code",[_._v("createProduct()")]),_._v(" 方法来创建具体的 "),v("code",[_._v("Product")]),_._v("。而 "),v("code",[_._v("Creator")]),_._v(" 自身通常是实现具体 "),v("code",[_._v("Product")]),_._v(" 相关业务操作的地方。")])])]),_._v(" "),v("li",[_._v("Concrete Creators：具体的工厂方法实现类，通常只负责创建具体的产品实例。在实际开发中，不用每次调用都创建新的实例，可以用缓存/对象池/单例来实现。")])]),_._v(" "),v("h2",{attrs:{id:"_4-适用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-适用场景"}},[_._v("#")]),_._v(" 4. 适用场景")]),_._v(" "),v("h3",{attrs:{id:"_4-1-业务场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-业务场景"}},[_._v("#")]),_._v(" 4.1 业务场景")]),_._v(" "),v("ul",[v("li",[_._v("当不确定一个对象的具体类型，可以将创建对象的代码替换为工厂方法。")]),_._v(" "),v("li",[_._v("如果可以确定某个组件或者对象未来一定会扩展出新的类别，也可以提前将这个对象的创建抽象为一个工厂方法。")])]),_._v(" "),v("h3",{attrs:{id:"_4-2-开源实例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-开源实例"}},[_._v("#")]),_._v(" 4.2 开源实例")]),_._v(" "),v("p",[_._v("JDK 中：")]),_._v(" "),v("ul",[v("li",[_._v("java.util.Calendar")]),_._v(" "),v("li",[_._v("java.util.ResourceBundle")]),_._v(" "),v("li",[_._v("java.nio.charset.Charset")]),_._v(" "),v("li",[_._v("java.util.EnumSet")])]),_._v(" "),v("h2",{attrs:{id:"_5-实现细节和技巧"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-实现细节和技巧"}},[_._v("#")]),_._v(" 5. 实现细节和技巧")]),_._v(" "),v("ul",[v("li",[_._v("工厂方法构造的产品对象必须实现同一个 "),v("code",[_._v("interface")]),_._v("。")]),_._v(" "),v("li",[_._v("统一的产品 "),v("code",[_._v("interface")]),_._v(" 必须包含所有在产品使用过程中会调用的主要方法。")]),_._v(" "),v("li",[_._v("如果产品对象具体类型太多可以尝试为产品子类创建子类，复用一部分共用的构造逻辑。")]),_._v(" "),v("li",[_._v("如果具体的产品对象过于复杂，内部对象层次和组合很多，可以尝试改为使用生成器模式。")])]),_._v(" "),v("h2",{attrs:{id:"_6-优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-优缺点"}},[_._v("#")]),_._v(" 6. 优缺点")]),_._v(" "),v("p",[_._v("优点：")]),_._v(" "),v("ul",[v("li",[_._v("解耦业务逻辑和具体产品。")]),_._v(" "),v("li",[_._v("符合单一职责原则。将创建产品对象的代码放在一个单一的位置。")]),_._v(" "),v("li",[_._v("符合开闭原则。无需修改业务逻辑代码，就可以通过新增产品子类来扩展产品类型。")])]),_._v(" "),v("p",[_._v("缺点：")]),_._v(" "),v("ul",[v("li",[_._v("使用工厂模式会引入很多新的接口和子类，使代码结构变复杂，但这属于工程组织结构的问题了，需要设计模式外的工具方法解决。")])]),_._v(" "),v("h2",{attrs:{id:"_7-和其他模式的关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-和其他模式的关系"}},[_._v("#")]),_._v(" 7. 和其他模式的关系")]),_._v(" "),v("h3",{attrs:{id:"_7-1-和其他-工厂-对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-和其他-工厂-对比"}},[_._v("#")]),_._v(" 7.1 和其他“工厂”对比")]),_._v(" "),v("p",[v("RouterLink",{attrs:{to:"/design/design_patterns/几种“工厂”之间的区别.html"}},[_._v("几个名字带“工厂”的创建型模式对比")])],1),_._v(" "),v("h3",{attrs:{id:"_7-2-和其他创建型模式的关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-和其他创建型模式的关系"}},[_._v("#")]),_._v(" 7.2 和其他创建型模式的关系")]),_._v(" "),v("ul",[v("li",[_._v("和单例模式没什么关系。")]),_._v(" "),v("li",[_._v("工厂方法实现起来较简单，复杂起来可以演化为抽象工厂模式、原型模式或者生成器模式。")])]),_._v(" "),v("h3",{attrs:{id:"_7-3-和其他非创建型模式的关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-和其他非创建型模式的关系"}},[_._v("#")]),_._v(" 7.3 和其他非创建型模式的关系")])])}),[],!1,null,null,null);t.default=r.exports}}]);