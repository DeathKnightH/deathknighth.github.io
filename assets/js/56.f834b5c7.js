(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{423:function(_,v,t){"use strict";t.r(v);var d=t(44),a=Object(d.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"数据库设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库设计"}},[_._v("#")]),_._v(" 数据库设计")]),_._v(" "),t("h2",{attrs:{id:"_1-设计理论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-设计理论"}},[_._v("#")]),_._v(" 1. 设计理论")]),_._v(" "),t("h3",{attrs:{id:"_1-1-名词解释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-名词解释"}},[_._v("#")]),_._v(" 1.1 名词解释")]),_._v(" "),t("ul",[t("li",[_._v("Table（表）：数据库的数据的一个集合，由多个列和行组成，同一张表的数据共用同样的列。")]),_._v(" "),t("li",[_._v("Attribute（属性）：表的列名。")]),_._v(" "),t("li",[_._v("Tuple（元组）：表的一行数据。")]),_._v(" "),t("li",[_._v("Domain（域）：属性的数据类型。")]),_._v(" "),t("li",[_._v("Relation（依赖）：属性之间存在的某种联系。")]),_._v(" "),t("li",[_._v("Schema（模式）：逻辑结构，属性在逻辑上组成的集合。")]),_._v(" "),t("li",[_._v("Key（键）：由一个或多个属性组成的一个整体，通常是有唯一性的（即当两个元组的键相同，则其所有属性都相同）。一个属性可以存在于不同的键中，一张表也可以有多个键。")]),_._v(" "),t("li",[_._v("Primary key（主键）：唯一性标识，不可为空，一个表中只能有一个主键。")]),_._v(" "),t("li",[_._v("Candidate key（候选键）：由一个或多个属性组成的一个整体，具有主键的特征，都有资格成为主键。")]),_._v(" "),t("li",[_._v("Super key（超键）：键的超集，包含键的属性集合。")]),_._v(" "),t("li",[_._v("Foreign key（外键）：在关系 A 中的一个或多个属性在关系 B 中是一个 key，那么该属性集合在 A 中被称为外键。")]),_._v(" "),t("li",[_._v("Prime attribute（主属性）：所有候选键里包含的属性都是主属性。")]),_._v(" "),t("li",[_._v("Projection（投影）：")]),_._v(" "),t("li",[_._v("Selection（选择）：按一定条件选择元组。")]),_._v(" "),t("li",[_._v("Cross join（交叉连接）：又称笛卡尔积，将关系 A 和关系 B 中的每一行进行组合，保留所有组合结果。")]),_._v(" "),t("li",[_._v("Natural join（自然连接）：将关系 A 和关系 B 中的每一行进行匹配，只保留相同的部分，去掉不匹配的部分。")]),_._v(" "),t("li",[_._v("Theta join（θ连接）：又称连接，带约束条件的笛卡尔积。即在两个关系的笛卡尔积中根据条件过滤获取符合条件元组集合。")]),_._v(" "),t("li",[_._v("Outer join（外连接）：自然连接时将不匹配的部分属性置为 null，并加入结果集。")]),_._v(" "),t("li",[_._v("Division（除法运算）：关系 A 除以关系 B 得到结果 T，T 的属性是所有在 A 中但不在 B 中的属性集合，T 的元组包含了 A 所有元组和 B 所有的元组的一一组合。")])]),_._v(" "),t("h3",{attrs:{id:"_1-2-函数依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-函数依赖"}},[_._v("#")]),_._v(" 1.2 函数依赖")]),_._v(" "),t("p",[_._v("在一个关系 R 中，属性组 A 的值由属性组 B 决定，即唯一确定的 B 能确定唯一的 A 值。")]),_._v(" "),t("ul",[t("li",[_._v("完全函数依赖：必须由完整的一组 B 属性才能决定 A。")]),_._v(" "),t("li",[_._v("部分函数依赖：B 中的部分属性也可以决定 A。")]),_._v(" "),t("li",[_._v("传递函数依赖：属性组 A 决定 B，B 决定 C，且同时满足，B/C 均不包含于 A，C 不包含于 B，B 不能决定 A，则说 C 传递依赖于 A。")])]),_._v(" "),t("h3",{attrs:{id:"_1-3-异常和范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-异常和范式"}},[_._v("#")]),_._v(" 1.3 异常和范式")]),_._v(" "),t("h4",{attrs:{id:"_1-3-1-异常"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-1-异常"}},[_._v("#")]),_._v(" 1.3.1 异常")]),_._v(" "),t("p",[_._v("不符合范式会造成异常。\n以一张学生选课表为例：")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("学号")]),_._v(" "),t("th",[_._v("姓名")]),_._v(" "),t("th",[_._v("年龄")]),_._v(" "),t("th",[_._v("学院")]),_._v(" "),t("th",[_._v("院长")]),_._v(" "),t("th",[_._v("课程名称")]),_._v(" "),t("th",[_._v("成绩")]),_._v(" "),t("th",[_._v("学分")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("001")]),_._v(" "),t("td",[_._v("A")]),_._v(" "),t("td",[_._v("20")]),_._v(" "),t("td",[_._v("计算机")]),_._v(" "),t("td",[_._v("院长1")]),_._v(" "),t("td",[_._v("数据结构")]),_._v(" "),t("td",[_._v("70")]),_._v(" "),t("td",[_._v("2")])]),_._v(" "),t("tr",[t("td",[_._v("002")]),_._v(" "),t("td",[_._v("B")]),_._v(" "),t("td",[_._v("20")]),_._v(" "),t("td",[_._v("软件")]),_._v(" "),t("td",[_._v("院长2")]),_._v(" "),t("td",[_._v("数据结构")]),_._v(" "),t("td",[_._v("65")]),_._v(" "),t("td",[_._v("2")])]),_._v(" "),t("tr",[t("td",[_._v("001")]),_._v(" "),t("td",[_._v("A")]),_._v(" "),t("td",[_._v("20")]),_._v(" "),t("td",[_._v("计算机")]),_._v(" "),t("td",[_._v("院长1")]),_._v(" "),t("td",[_._v("编译原理")]),_._v(" "),t("td",[_._v("80")]),_._v(" "),t("td",[_._v("1")])]),_._v(" "),t("tr",[t("td",[_._v("003")]),_._v(" "),t("td",[_._v("C")]),_._v(" "),t("td",[_._v("21")]),_._v(" "),t("td",[_._v("计算机")]),_._v(" "),t("td",[_._v("院长1")]),_._v(" "),t("td",[_._v("编译原理")]),_._v(" "),t("td",[_._v("90")]),_._v(" "),t("td",[_._v("1")])])])]),_._v(" "),t("ul",[t("li",[_._v("数据冗余：同一个学生选修了 n 门课，则 (学号，姓名，年龄)在表中重复了 n 次。")]),_._v(" "),t("li",[_._v("修改异常：如果修改一门课的学分，那么要同时修改选了这门课的所有学生对应的元组的学分，否则或造成修改异常。")]),_._v(" "),t("li",[_._v("删除异常：如果删除一门课，那么要同时删除选了这门课所有学生对应的元组，否则会造成删除异常。")]),_._v(" "),t("li",[_._v("插入异常：插入一个元组，如果课程不存在，则会造成插入异常。")])]),_._v(" "),t("h4",{attrs:{id:"_1-3-2-1nf-第一范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-2-1nf-第一范式"}},[_._v("#")]),_._v(" 1.3.2 1NF 第一范式")]),_._v(" "),t("p",[_._v("定义：属性不可分。\n理解：一列只能表示单一的属性，不能把多种属性合并到一列。\n实现方式：不用特地去实现，现代关系型数据库的表天然就是符合第一范式的，每个属性(列)只能使用一种类型。")]),_._v(" "),t("h4",{attrs:{id:"_1-3-3-2nf-第二范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-3-2nf-第二范式"}},[_._v("#")]),_._v(" 1.3.3 2NF 第二范式")]),_._v(" "),t("p",[_._v("定义：在满足 1NF 的前提下，每个非主属性都完全依赖于键码。\n理解：在 1NF 的基础上，消除部分依赖。\n实现方式：拆分表属性，还是以上述学生选课表为例：\n(学号,课程名称) 是候选键，但是其中(学号)能决定(姓名,年龄,学院)，同时(课程名称)能决定(学分)，有部分函数依赖。\n实现 2NF 的方式是拆分表的属性，最后形成 3 张表：")]),_._v(" "),t("p",[t("strong",[_._v("学生信息表")])]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("学号")]),_._v(" "),t("th",[_._v("姓名")]),_._v(" "),t("th",[_._v("年龄")]),_._v(" "),t("th",[_._v("学院")]),_._v(" "),t("th",[_._v("院长")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("001")]),_._v(" "),t("td",[_._v("A")]),_._v(" "),t("td",[_._v("20")]),_._v(" "),t("td",[_._v("计算机")]),_._v(" "),t("td",[_._v("院长1")])]),_._v(" "),t("tr",[t("td",[_._v("002")]),_._v(" "),t("td",[_._v("B")]),_._v(" "),t("td",[_._v("20")]),_._v(" "),t("td",[_._v("软件")]),_._v(" "),t("td",[_._v("院长2")])]),_._v(" "),t("tr",[t("td",[_._v("003")]),_._v(" "),t("td",[_._v("C")]),_._v(" "),t("td",[_._v("21")]),_._v(" "),t("td",[_._v("计算机")]),_._v(" "),t("td",[_._v("院长1")])])])]),_._v(" "),t("p",[t("strong",[_._v("课程信息表")])]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("课程名称")]),_._v(" "),t("th",[_._v("学分")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("数据结构")]),_._v(" "),t("td",[_._v("2")])]),_._v(" "),t("tr",[t("td",[_._v("编译原理")]),_._v(" "),t("td",[_._v("1")])])])]),_._v(" "),t("p",[t("strong",[_._v("学生选课表")])]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("学号")]),_._v(" "),t("th",[_._v("课程名称")]),_._v(" "),t("th",[_._v("成绩")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("001")]),_._v(" "),t("td",[_._v("数据结构")]),_._v(" "),t("td",[_._v("70")])]),_._v(" "),t("tr",[t("td",[_._v("002")]),_._v(" "),t("td",[_._v("数据结构")]),_._v(" "),t("td",[_._v("65")])]),_._v(" "),t("tr",[t("td",[_._v("001")]),_._v(" "),t("td",[_._v("编译原理")]),_._v(" "),t("td",[_._v("80")])]),_._v(" "),t("tr",[t("td",[_._v("003")]),_._v(" "),t("td",[_._v("编译原理")]),_._v(" "),t("td",[_._v("90")])])])]),_._v(" "),t("p",[_._v("这样就消除了候选键的部分依赖，满足了 2NF。")]),_._v(" "),t("p",[_._v("但是拆分后的"),t("code",[_._v("学生信息表")]),_._v("依旧存在异常，")]),_._v(" "),t("h4",{attrs:{id:"_1-3-4-3nf-第三范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-4-3nf-第三范式"}},[_._v("#")]),_._v(" 1.3.4 3NF 第三范式")]),_._v(" "),t("p",[_._v("定义：在满足 2NF 的前提下，每个非主属性都不传递依赖于键码。\n理解：在 2NF 的基础上，消除传递依赖。\n实现方式：还是拆分表属性，以 2NF 拆分后的表为例。")]),_._v(" "),t("p",[_._v("观察学生信息表，"),t("code",[_._v("学号")]),_._v("决定"),t("code",[_._v("学院")]),_._v("，学院决定院长，同时学院不能决定学号，学院和院长也不属于学号的一部分，因此院长传递依赖于学号，不符合 3NF。")]),_._v(" "),t("p",[_._v("可以将学生信息表进一步拆分为两个表：")]),_._v(" "),t("p",[t("strong",[_._v("学生信息表")])]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("学号")]),_._v(" "),t("th",[_._v("姓名")]),_._v(" "),t("th",[_._v("年龄")]),_._v(" "),t("th",[_._v("学院")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("001")]),_._v(" "),t("td",[_._v("A")]),_._v(" "),t("td",[_._v("20")]),_._v(" "),t("td",[_._v("计算机")])]),_._v(" "),t("tr",[t("td",[_._v("002")]),_._v(" "),t("td",[_._v("B")]),_._v(" "),t("td",[_._v("20")]),_._v(" "),t("td",[_._v("软件")])]),_._v(" "),t("tr",[t("td",[_._v("003")]),_._v(" "),t("td",[_._v("C")]),_._v(" "),t("td",[_._v("21")]),_._v(" "),t("td",[_._v("计算机")])])])]),_._v(" "),t("p",[t("strong",[_._v("学院信息表")])]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("学院")]),_._v(" "),t("th",[_._v("院长")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("计算机")]),_._v(" "),t("td",[_._v("院长1")])]),_._v(" "),t("tr",[t("td",[_._v("软件")]),_._v(" "),t("td",[_._v("院长2")])])])]),_._v(" "),t("h2",{attrs:{id:"_2-设计流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-设计流程"}},[_._v("#")]),_._v(" 2. 设计流程")]),_._v(" "),t("p",[_._v("数据库的规范设计流程分为 6 个阶段：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("需求分析：分析数据、功能、性能需求。")]),_._v(" "),t("p",[_._v("通常采用结构化分析方法（structured analysis），自顶向下，逐层分解分析系统。")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("分析的对象主要分为处理过程和数据。")])]),_._v(" "),t("li",[t("p",[_._v("对于处理过程，常用判定表或者判定树来描述。")])]),_._v(" "),t("li",[t("p",[_._v("对于数据，和处理过程同步，常用不同层次的数据流图表述。")])])])]),_._v(" "),t("li",[t("p",[_._v("概念结构设计：采用 E-R 模型设计概念结构，输出物为 E-R 图。")])]),_._v(" "),t("li",[t("p",[_._v("逻辑结构设计：将 E-R 图转换为数据库表结构，输出为数据库表。")])]),_._v(" "),t("li",[t("p",[_._v("数据库物理设计：为设计的数据库选择合适的物理存储结构和路径。")]),_._v(" "),t("p",[_._v("对数据库实际运行事务进行分析，选择合适的数据库存储结构。\n常见的存储结构有：")]),_._v(" "),t("ul",[t("li",[_._v("索引方法，主要是 B+ 树")]),_._v(" "),t("li",[_._v("聚簇方法")]),_._v(" "),t("li",[_._v("hash 方法")])])]),_._v(" "),t("li",[t("p",[_._v("数据库实施：编码，测试，试运行。")])]),_._v(" "),t("li",[t("p",[_._v("数据库运行与维护：正式运行数据库，以及在运行中维护数据库。")])])]),_._v(" "),t("p",[_._v("平时数据库设计最主要的工作内容在需求分析、概念结构设计和逻辑结构设计，即分析需求、画 E-R 图和根据 E-R 图建表。")]),_._v(" "),t("h3",{attrs:{id:"_2-1-e-r-图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-e-r-图"}},[_._v("#")]),_._v(" 2.1 E-R 图")]),_._v(" "),t("p",[_._v("Entity-Relationship（实体关系图）是用来描述关系型数据的重要手段，由3个部分组成：实体、属性、关系。")]),_._v(" "),t("p",[_._v("实体关系分为3种：")]),_._v(" "),t("ul",[t("li",[_._v("1 对 1")]),_._v(" "),t("li",[_._v("1 对 多")]),_._v(" "),t("li",[_._v("多 对 多")])]),_._v(" "),t("h3",{attrs:{id:"_2-2-基于-e-r-图的数据库表结构设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-基于-e-r-图的数据库表结构设计"}},[_._v("#")]),_._v(" 2.2 基于 E-R 图的数据库表结构设计")]),_._v(" "),t("ul",[t("li",[_._v("确定实体和关系")]),_._v(" "),t("li",[_._v("确定数据、属性")]),_._v(" "),t("li",[_._v("标准化数据")]),_._v(" "),t("li",[_._v("处理关系")]),_._v(" "),t("li",[_._v("检验设计")])])])}),[],!1,null,null,null);v.default=a.exports}}]);