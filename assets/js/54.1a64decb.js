(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{421:function(t,a,_){"use strict";_.r(a);var r=_(44),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"生成器模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#生成器模式"}},[t._v("#")]),t._v(" 生成器模式")]),t._v(" "),_("h2",{attrs:{id:"_1-概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念"}},[t._v("#")]),t._v(" 1. 概念")]),t._v(" "),_("p",[t._v("Builder 是一种创建型模式，主要目的是使用一组定义好的创建步骤创建不同的复杂对象。")]),t._v(" "),_("h2",{attrs:{id:"_2-意图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-意图"}},[t._v("#")]),t._v(" 2. 意图")]),t._v(" "),_("p",[t._v("封装一个复杂对象的构造过程，允许子类/实现类自定义不同的构造步骤。")]),t._v(" "),_("h2",{attrs:{id:"_3-类图示例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-类图示例"}},[t._v("#")]),t._v(" 3. 类图示例")]),t._v(" "),_("h2",{attrs:{id:"_4-适用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-适用场景"}},[t._v("#")]),t._v(" 4. 适用场景")]),t._v(" "),_("ul",[_("li",[t._v("当一个对象的构造函数的可选参数特别多时，为了避免重载过多的构造函数，可以使用生成器模式：\n"),_("ul",[_("li",[t._v("只定义必须实现的构造步骤，其他可选的步骤交由子类/实现类来实现。")])])]),t._v(" "),_("li",[t._v("当构造的两种对象仅存在很细微的细节差别时，为了避免完全重写一个构造过程大部分相同的工厂类/构造函数，可以使用生成器模式：\n"),_("ul",[_("li",[t._v("在生成器的接口/抽象类中定义基本的生成步骤和构造过程。")]),t._v(" "),_("li",[t._v("在生成器的子类/实现类中负责具体的差异性细节的构造。")])])]),t._v(" "),_("li",[t._v("当构造的对象特别复杂或者是一个对象组合树时，可以使用生成器模式：\n"),_("ul",[_("li",[t._v("生成的步骤可在子类/实现类中自定义，可以重复或者递归调用某些步骤。")]),t._v(" "),_("li",[t._v("整个对象树/复杂对象生成完成前不会返回，避免业务逻辑使用一个不完整的复杂对象，造成难以定位的问题。")])])])]),t._v(" "),_("h2",{attrs:{id:"_5-与其他设计模式的关系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-与其他设计模式的关系"}},[t._v("#")]),t._v(" 5. 与其他设计模式的关系")])])}),[],!1,null,null,null);a.default=s.exports}}]);