(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{365:function(a,t,r){"use strict";r.r(t);var s=r(44),_=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"单源最短路径"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单源最短路径"}},[a._v("#")]),a._v(" 单源最短路径")]),a._v(" "),r("h2",{attrs:{id:"_1-定义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-定义"}},[a._v("#")]),a._v(" 1. 定义")]),a._v(" "),r("p",[a._v("给定一个带权重的有向图 G=(V,E) 和权重函数 w: E → R，定义图中一条路径 p=<v0,v1,...,vk> 的权重 w(p) 是构成该路径的所有边的权重之和。")]),a._v(" "),r("p",[a._v("从结点 u 到结点 v 的最短路径是 u~v 的所有路径中权重最小的路径。")]),a._v(" "),r("p",[a._v("单源指定一个源结点 s∈V，计算 s 到每一个结点 v∈V 的最短路径。")]),a._v(" "),r("h2",{attrs:{id:"_2-特殊情况"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-特殊情况"}},[a._v("#")]),a._v(" 2. 特殊情况")]),a._v(" "),r("h3",{attrs:{id:"_2-1-负权重的边"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-负权重的边"}},[a._v("#")]),a._v(" 2.1 负权重的边")]),a._v(" "),r("h3",{attrs:{id:"_2-2-环路"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-环路"}},[a._v("#")]),a._v(" 2.2 环路")]),a._v(" "),r("h2",{attrs:{id:"_3-性质"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-性质"}},[a._v("#")]),a._v(" 3. 性质")]),a._v(" "),r("h2",{attrs:{id:"_4-算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-算法"}},[a._v("#")]),a._v(" 4. 算法")]),a._v(" "),r("h3",{attrs:{id:"_4-1-bellman-ford-算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-bellman-ford-算法"}},[a._v("#")]),a._v(" 4.1 Bellman-Ford 算法")]),a._v(" "),r("p",[a._v("解决一般性的单源最短路径问题。")]),a._v(" "),r("h3",{attrs:{id:"_4-2-dijkstra-算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-dijkstra-算法"}},[a._v("#")]),a._v(" 4.2 Dijkstra 算法")]),a._v(" "),r("p",[a._v("解决带权重均为非负值情况下的单源最短路径问题。")])])}),[],!1,null,null,null);t.default=_.exports}}]);