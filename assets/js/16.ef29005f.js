(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{368:function(a,t,_){a.exports=_.p+"assets/img/facade.drawio.72e94e9c.png"},448:function(a,t,_){"use strict";_.r(t);var s=_(44),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"外观模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#外观模式"}},[a._v("#")]),a._v(" 外观模式")]),a._v(" "),s("h2",{attrs:{id:"_1-概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念"}},[a._v("#")]),a._v(" 1.概念")]),a._v(" "),s("p",[a._v("外观模式是一种结构性设计模式，又称 Facade/门面模式。为一堆复杂的功能或者整个程序库提供一个简单的对外接口。")]),a._v(" "),s("h2",{attrs:{id:"_2-意图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-意图"}},[a._v("#")]),a._v(" 2.意图")]),a._v(" "),s("p",[a._v("如果在自己的代码中要使用另一个类库提供的某个功能，需要自行初始化这个类库中各种对象，并按说明书给出的顺序执行对象中方法，实际只用了一小部分功能，却要学习/管理一整个复杂的代码库。")]),a._v(" "),s("p",[a._v("而外观模式通过将用户真正关心的核心功能整合起来，并提供一个统一的简单接口，完成对整个第三方类库的使用。")]),a._v(" "),s("h2",{attrs:{id:"_3-类图示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-类图示例"}},[a._v("#")]),a._v(" 3.类图示例")]),a._v(" "),s("p",[s("img",{attrs:{src:_(368),alt:"facade"}})]),a._v(" "),s("h2",{attrs:{id:"_4-适用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-适用场景"}},[a._v("#")]),a._v(" 4.适用场景")]),a._v(" "),s("h3",{attrs:{id:"_4-1-实际业务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-实际业务"}},[a._v("#")]),a._v(" 4.1 实际业务")]),a._v(" "),s("ul",[s("li",[a._v("对称加解密是一个复杂的过程，中间要初始化 Cipher/向量/密钥，还要通过一系列操作最终才能将指定数据加解密，而这些中间操作用户不需要了解，也不需要懂得如何初始化，核心诉求只是对称加解密。那么通过使用外观模式：\n"),s("ul",[s("li",[a._v("对外只提供一个加密接口和一个解密接口，用户只需要提供需要加/解密的 byte 数组即可使用。")]),a._v(" "),s("li",[a._v("facade 类中缺省提供了 AES-256-GCM 的加密模式，产品安装时通过自动化脚本生成了初始密钥组件，对一般用户可直接使用，有特殊要求的用户也可以自行定制算法和初始密钥。")])])])]),a._v(" "),s("h3",{attrs:{id:"_4-2-开源实例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-开源实例"}},[a._v("#")]),a._v(" 4.2 开源实例")]),a._v(" "),s("ul",[s("li",[a._v("各种工具类库都是这么个思路，比如我用过的几个视频/音频转码工具，都是对外提供一个命令行工具或者干脆就是一个命令，直接把目录下的对象文件进行转码封装，不需要对音视频处理类库有深入的了解。")])]),a._v(" "),s("h2",{attrs:{id:"_5-实现细节和技巧"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-实现细节和技巧"}},[a._v("#")]),a._v(" 5.实现细节和技巧")]),a._v(" "),s("ul",[s("li",[a._v("使用外观模式的前提是用户只使用一个庞大框架/类库的"),s("strong",[a._v("小部分")]),a._v("特定功能。")]),a._v(" "),s("li",[a._v("外观模式的目的是解耦用户代码和子系统/类库代码，如果外观的存在可以让两者独立修改而不会互相影响，那就是成功的。")]),a._v(" "),s("li",[a._v("外观类本身应该是简单的，如果外观类自身变得复杂和过于臃肿，那可以考虑将部分行为抽象成新的另一个外观。")])]),a._v(" "),s("h2",{attrs:{id:"_6-优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-优缺点"}},[a._v("#")]),a._v(" 6.优缺点")]),a._v(" "),s("p",[a._v("优点：")]),a._v(" "),s("ul",[s("li",[a._v("符合最少知识原则，用户只需要了解和使用核心功能。")]),a._v(" "),s("li",[a._v("能将简单应用和复杂子系统分开独立。")])]),a._v(" "),s("p",[a._v("缺点：")]),a._v(" "),s("ul",[s("li",[a._v("外观类随着程序迭代开发可能成为危险的"),s("strong",[a._v("上帝对象")]),a._v("。")])]),a._v(" "),s("h2",{attrs:{id:"_7-与其他设计模式的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-与其他设计模式的关系"}},[a._v("#")]),a._v(" 7.与其他设计模式的关系")])])}),[],!1,null,null,null);t.default=r.exports}}]);