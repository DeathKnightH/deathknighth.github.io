(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{377:function(e,a,t){"use strict";t.r(a);var s=t(44),r=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"aqs-abstract-queued-synchronizer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aqs-abstract-queued-synchronizer"}},[e._v("#")]),e._v(" AQS(Abstract Queued Synchronizer)")]),e._v(" "),t("h2",{attrs:{id:"_1-核心思想"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-核心思想"}},[e._v("#")]),e._v(" 1. 核心思想")]),e._v(" "),t("ul",[t("li",[e._v("如果被请求的共享资源空闲")])]),e._v(" "),t("p",[e._v("将当前请求资源的线程设置为当前工作线程，并将共享资源加锁。")]),e._v(" "),t("ul",[t("li",[e._v("如果被请求的共享资源被占用")])]),e._v(" "),t("p",[e._v("将暂时获取不到锁的线程放入队列中等待解锁时唤醒，这个队列在 AQS 中是一个 CLH 队列。\nAQS 将每个请求资源的线程封装成一个 Node 放入 CLH 队列，实现锁分配。")]),e._v(" "),t("h2",{attrs:{id:"_2-实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现原理"}},[e._v("#")]),e._v(" 2. 实现原理")]),e._v(" "),t("h3",{attrs:{id:"_2-1-同步状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-同步状态"}},[e._v("#")]),e._v(" 2.1 同步状态")]),e._v(" "),t("p",[e._v("AQS 内部使用一个 volatile 修饰的 int 变量表示同步状态：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private volatile int state;\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[e._v("有3个方法可以直接操作 state，其他方法都是通过这3个方法间接操作 state：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 获取当前 state 值，相当于 volatile 读\nprotected final int getState() {\n  return state;\n}\n\n// 设置 state 值，相当于 volatile 写\nprotected final void setState(int newState) {\n  state = newState;\n}\n\n// 使用 CAS 根据 expect 设置 state 的值为 update，相当于原子地 volatile 读+写\nprotected final boolean compareAndSetState(int expect, int update) {\n  return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br"),t("span",{staticClass:"line-number"},[e._v("12")]),t("br"),t("span",{staticClass:"line-number"},[e._v("13")]),t("br"),t("span",{staticClass:"line-number"},[e._v("14")]),t("br")])]),t("h3",{attrs:{id:"_2-2-资源共享方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-资源共享方式"}},[e._v("#")]),e._v(" 2.2 资源共享方式")]),e._v(" "),t("p",[e._v("分为两种：")]),e._v(" "),t("ul",[t("li",[e._v("独占\n同一时间只有一个线程能够使用共享资源，独占锁根据线程竞争方式还可以分为：\n"),t("ul",[t("li",[e._v("公平锁：根据线程在等待队列中的顺序，先到先得。")]),e._v(" "),t("li",[e._v("非公平锁：所有等待线程一起竞争，谁竞争到谁得。")])])]),e._v(" "),t("li",[e._v("共享")])]),e._v(" "),t("p",[e._v("同一时间可以有多个线程访问共享资源，例如 CountDownLatch、Semaphore、CyclicBarrier、ReadWriteLock。\n其实 ReentrantReadWriteLock 是两种混合的，读和读之间是共享的，写和其他操作之间是独占的。")]),e._v(" "),t("h3",{attrs:{id:"_2-3-sync-queue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-sync-queue"}},[e._v("#")]),e._v(" 2.3 Sync queue")]),e._v(" "),t("p",[e._v("AQS 内部的锁队列是一个 CLH，虚拟双向队列，其实存储的不是一个队列整体，而是队列头结点和尾结点，队列关系由 Node 类来维护。\n"),t("img",{attrs:{src:"https://user-images.githubusercontent.com/19852729/124567435-95765700-de76-11eb-836c-970013d17d44.png",alt:"image"}})]),e._v(" "),t("p",[e._v("Node 内部除了封装了等待线程、前驱、后驱结点，还有 waitStatus 和 nextWaiter 结点指针。")]),e._v(" "),t("ul",[t("li",[e._v("waitStatus 表示了当前 Node 的状态，只有以下5种值：\n"),t("ul",[t("li",[t("p",[e._v("SIGNAL(-1)")]),e._v(" "),t("p",[e._v("表示后继结点需要被唤醒。当前结点需要 unpark")])]),e._v(" "),t("li",[t("p",[e._v("CANCELLED(1)")]),e._v(" "),t("p",[e._v("结点中的线程已超时或者中断，表示为这个状态的结点不会再改变状态。")])]),e._v(" "),t("li",[t("p",[e._v("CONDITION(-2)")]),e._v(" "),t("p",[e._v("这个状态表示这个 Node 是在一个 Condition 队列中。当有其他线程调用了 Condition 的 signal() 方法后，会从 Condition 队列转移到 Sync 队列。")])]),e._v(" "),t("li",[t("p",[e._v("PROPAGATE(-3)")]),e._v(" "),t("p",[e._v("在 doReleaseShared 中保证 releaseShared 会被传递给其他结点，通常只有 head node 会设置这个状态。")])]),e._v(" "),t("li",[t("p",[e._v("0")]),e._v(" "),t("p",[e._v("表示等待状态，新 Node 进入 Sync 队列时的默认状态。\n可以看出 waitStatus <= 0 时处于正常等待状态，waitStatus > 0 时处于取消状态。")])])])]),e._v(" "),t("li",[e._v("nextWaiter 主要用于有 Condition 存在时，使用这个 nextWaiter 指针组成一个单链表形式的 Condition 队列。")])]),e._v(" "),t("h3",{attrs:{id:"_2-4-conditionobject"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-conditionobject"}},[e._v("#")]),e._v(" 2.4 ConditionObject")]),e._v(" "),t("p",[e._v("ConditionObject 实现了 Condition 接口，主要实现了两个类型的操作，await 操作用于等待 signal，signal 操作用于唤醒等待的线程。\n类的内部维护了一个由 Node 组成的 Condition 队列，说是队列其实是一个记录了头结点和尾结点的单链表。\nCondition 队列中的 Node 的 nextWaiter 指向下一个 Node， 状态为 CONDITION(-2) 或者 CANCELLED(1)。")]),e._v(" "),t("h3",{attrs:{id:"_2-5-核心方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-核心方法"}},[e._v("#")]),e._v(" 2.5 核心方法")]),e._v(" "),t("h4",{attrs:{id:"_2-5-1-独占方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-1-独占方式"}},[e._v("#")]),e._v(" 2.5.1 独占方式")]),e._v(" "),t("ul",[t("li",[e._v("acquire")])]),e._v(" "),t("p",[e._v("以独占模式获取资源，忽略中断。")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public final void acquire(int arg) {\n  if (!tryAcquire(arg) &&\n    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n    selfInterrupt();\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br")])]),t("p",[t("code",[e._v("acquire(int)")]),e._v(" 方法内部逻辑的流程图如下：\n"),t("img",{attrs:{src:"https://user-images.githubusercontent.com/19852729/124858111-09803e80-dfe0-11eb-9d6f-71cc350322d9.png",alt:"acquire"}})]),e._v(" "),t("p",[t("code",[e._v("忽略中断")]),e._v("体现在 "),t("code",[e._v("acquireQueued(Node, int)")]),e._v(" 方法上，如果线程中断，不会立刻响应，会在获取到资源后再返还 false，"),t("code",[e._v("acquire(int)")]),e._v(" 方法收到 false 返还值再调用 interrupt() 方法中断当前线程。\n"),t("code",[e._v("acquireQueued(Node, int)")]),e._v(" 内部是一个无限循环，循环内的逻辑如下：\n"),t("img",{attrs:{src:"https://user-images.githubusercontent.com/19852729/124876144-465a2e80-dffc-11eb-8514-b2aa57a9be33.png",alt:"acquireQueued"}})]),e._v(" "),t("ul",[t("li",[e._v("release")])]),e._v(" "),t("p",[e._v("以独占模式释放资源。")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public final boolean release(int arg) {\n  if (tryRelease(arg)) {\n    Node h = head;\n    if (h != null && h.waitStatus != 0)\n      unparkSuccessor(h);\n    return true;\n  }\n  return false;\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br")])]),t("p",[t("code",[e._v("tryRelease(int)")]),e._v("方法默认实现是直接抛异常，需要依赖子类实现，具体情况具体分析。\n"),t("code",[e._v("unparkSuccessor(Node)")]),e._v("方法的作用就是为了 unpark 传入参数 Node 的后继结点。比如在上面 "),t("code",[e._v("acquire(int)")]),e._v(" 流程中被执行了 park 的节点。")]),e._v(" "),t("h4",{attrs:{id:"_2-5-2-共享方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-2-共享方式"}},[e._v("#")]),e._v(" 2.5.2 共享方式")]),e._v(" "),t("ul",[t("li",[e._v("acquireShared")])]),e._v(" "),t("p",[e._v("以共享模式获取资源。")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public final void acquireShared(int arg) {\n  if (tryAcquireShared(arg) < 0)\n    doAcquireShared(arg);\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br")])]),t("p",[t("code",[e._v("tryAcquireShared(arg)")]),e._v("方法默认实现是直接抛异常，需要依赖子类实现，具体情况具体分析。但是需要注意返回值的定义，"),t("code",[e._v("<0")]),e._v(" 表示失败，"),t("code",[e._v("==0")]),e._v(" 表示成功但是没有剩余许可，"),t("code",[e._v(">0")]),e._v(" 表示成功且还有剩余许可。由此也可以看出当获取许可成功时会直接返回，失败才会进入到 "),t("code",[e._v("doAcquireShared(arg)")]),e._v(" 方法。")]),e._v(" "),t("p",[t("code",[e._v("doAcquireShared(arg)")]),e._v("方法用于将当前线程加入同步队列。内部逻辑和 "),t("code",[e._v("acquireQueued")]),e._v(" 方法类似，区别在于当前结点获取许可成功后会去尝试继续唤醒后继结点。")]),e._v(" "),t("ul",[t("li",[e._v("releaseShared")])]),e._v(" "),t("p",[e._v("以共享模式释放资源。")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public final boolean releaseShared(int arg) {\n  if (tryReleaseShared(arg)) {\n    doReleaseShared();\n    return true;\n  }\n  return false;\n}\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br")])]),t("p",[t("code",[e._v("tryReleaseShared(arg)")]),e._v(" 方法默认实现是直接抛异常，需要依赖子类实现，具体情况具体分析。")]),e._v(" "),t("p",[t("code",[e._v("doReleaseShared()")]),e._v(" 方法用于 unpark 后继结点。")]),e._v(" "),t("h2",{attrs:{id:"_3-实际应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-实际应用"}},[e._v("#")]),e._v(" 3. 实际应用")]),e._v(" "),t("p",[e._v("java.util.concurrent 包下提供了很多基于 AQS 实现的同步器，日常开发使用这些同步器就够用")]),e._v(" "),t("h3",{attrs:{id:"_3-1-reentrantlock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-reentrantlock"}},[e._v("#")]),e._v(" 3.1 ReentrantLock")]),e._v(" "),t("h3",{attrs:{id:"_3-2-countdownlatch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-countdownlatch"}},[e._v("#")]),e._v(" 3.2 CountDownLatch")]),e._v(" "),t("h3",{attrs:{id:"_3-3-semaphore"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-semaphore"}},[e._v("#")]),e._v(" 3.3 Semaphore")]),e._v(" "),t("h3",{attrs:{id:"_3-4-cyclicbarrier"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-cyclicbarrier"}},[e._v("#")]),e._v(" 3.4 CyclicBarrier")]),e._v(" "),t("h2",{attrs:{id:"_4-自定义同步器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-自定义同步器"}},[e._v("#")]),e._v(" 4. 自定义同步器")]),e._v(" "),t("p",[e._v("AQS 采用"),t("strong",[e._v("模板方法")]),e._v("模式设计，acquire()/release() 等 public 方法都是 final 的，对子类开放了一些 protected 方法，供子类修改实现。")]),e._v(" "),t("ul",[t("li",[e._v("tryAcquire(int)\n独占方式，尝试获取资源，成功返回 true，失败返回 false。")]),e._v(" "),t("li",[e._v("tryRelease(int)\n独占方式，尝试释放资源，成功返回 true，失败返回 false。")]),e._v(" "),t("li",[e._v("tryAcquireShared(int)\n共享方式，尝试获取资源，失败返回负数，成功但没有剩余可用资源返回 0，成功且仍有剩余可用资源返回正数。")]),e._v(" "),t("li",[e._v("tryReleaseShared(int)\n共享方式，尝试释放资源，成功返回 true，失败返回 false。")]),e._v(" "),t("li",[e._v("isHeldExclusively()\n判断当前线程是否正在独占资源。用到 Condition 时才会重写这个方法。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);