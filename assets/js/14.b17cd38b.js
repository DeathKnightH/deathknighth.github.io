(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{359:function(_,t,v){_.exports=v.p+"assets/img/proxy.drawio.fd94ebf6.png"},446:function(_,t,v){"use strict";v.r(t);var a=v(44),r=Object(a.a)({},(function(){var _=this,t=_.$createElement,a=_._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h1",{attrs:{id:"代理模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代理模式"}},[_._v("#")]),_._v(" 代理模式")]),_._v(" "),a("h2",{attrs:{id:"_1-概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念"}},[_._v("#")]),_._v(" 1.概念")]),_._v(" "),a("p",[_._v("代理模式是一种结构型设计模式，又称 Proxy。代理模式就像字面上的意思，提供一个目标对象的替身来控制对目标对象的访问。")]),_._v(" "),a("h2",{attrs:{id:"_2-意图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-意图"}},[_._v("#")]),_._v(" 2.意图")]),_._v(" "),a("p",[_._v("代理的目的就是让用户在不直接接触/使用目标对象的前提下使用目标对象的功能，可以：")]),_._v(" "),a("ul",[a("li",[_._v("更好的管理目标对象生命周期。")]),_._v(" "),a("li",[_._v("做一些安全加固。")]),_._v(" "),a("li",[_._v("远程调用。")])]),_._v(" "),a("h2",{attrs:{id:"_3-类图示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-类图示例"}},[_._v("#")]),_._v(" 3.类图示例")]),_._v(" "),a("p",[a("img",{attrs:{src:v(359),alt:"proxy"}})]),_._v(" "),a("h2",{attrs:{id:"_4-适用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-适用场景"}},[_._v("#")]),_._v(" 4.适用场景")]),_._v(" "),a("h3",{attrs:{id:"_4-1-业务场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-业务场景"}},[_._v("#")]),_._v(" 4.1 业务场景")]),_._v(" "),a("ul",[a("li",[_._v("代理 connector 对象，做鉴权。")])]),_._v(" "),a("h3",{attrs:{id:"_4-2-开源实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-开源实例"}},[_._v("#")]),_._v(" 4.2 开源实例")]),_._v(" "),a("p",[_._v("jdk：")]),_._v(" "),a("ul",[a("li",[_._v("java.lang.reflect.Proxy")]),_._v(" "),a("li",[_._v("RMI 包")])]),_._v(" "),a("p",[_._v("spring：")]),_._v(" "),a("ul",[a("li",[_._v("AOP 默认是由动态代理实现的，基本原理就是为每个 bean 生成一个代理对象，通过在代理对象中在原对象方法前后加入切点来实现 AOP。")])]),_._v(" "),a("h2",{attrs:{id:"_5-实现细节与技巧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-实现细节与技巧"}},[_._v("#")]),_._v(" 5.实现细节与技巧")]),_._v(" "),a("ul",[a("li",[_._v("最好能找到现成的service 接口。")]),_._v(" "),a("li",[_._v("如果没有现成的接口，又不能修改 service 对象，可以让 proxy 继承 service，即用子类来做 proxy。")]),_._v(" "),a("li",[_._v("大部分时候在 proxy 中创建和管理 service 对象的生命周期。少数情况下可能会让用户自行创建并在构造 proxy 时传入 service 对象。")])]),_._v(" "),a("h2",{attrs:{id:"_6-优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-优缺点"}},[_._v("#")]),_._v(" 6.优缺点")]),_._v(" "),a("p",[_._v("优点：")]),_._v(" "),a("ul",[a("li",[_._v("符合开闭原则。")]),_._v(" "),a("li",[_._v("由 proxy 管理 service 生命周期从而获得了更好的灵活性，即使 service 还未初始化好，proxy 仍然可用。")])]),_._v(" "),a("p",[_._v("缺点：")]),_._v(" "),a("ul",[a("li",[_._v("因为可能在 proxy 中使用懒加载，所以服务响应可能会有延迟。")]),_._v(" "),a("li",[_._v("服务调用多了一层代码，如果代码组织不够清晰可能会造成混乱。")])]),_._v(" "),a("h2",{attrs:{id:"_7-与其他设计模式的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-与其他设计模式的关系"}},[_._v("#")]),_._v(" 7.与其他设计模式的关系")]),_._v(" "),a("h3",{attrs:{id:"_7-1-与装饰模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-与装饰模式"}},[_._v("#")]),_._v(" 7.1 与装饰模式")]),_._v(" "),a("p",[_._v("共同点：")]),_._v(" "),a("ul",[a("li",[_._v("都是内部封装目标对象。")]),_._v(" "),a("li",[_._v("都是和目标对象实现相同的接口。")])]),_._v(" "),a("p",[_._v("不同点：")]),_._v(" "),a("ul",[a("li",[_._v("装饰模式只负责增强目标对象的功能，目标对象的生命周期还是由调用者管理。")]),_._v(" "),a("li",[_._v("代理模式需要同时负责目标对象的生命周期管理，调用者只需要管理代理对象。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);