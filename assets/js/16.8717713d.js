(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{365:function(t,a,s){t.exports=s.p+"assets/img/composite.drawio.216eaf6c.png"},433:function(t,a,s){"use strict";s.r(a);var r=s(44),_=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"组合模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#组合模式"}},[t._v("#")]),t._v(" 组合模式")]),t._v(" "),r("h2",{attrs:{id:"_1-概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念"}},[t._v("#")]),t._v(" 1. 概念")]),t._v(" "),r("p",[t._v("Composite，又称对象树、Object Tree。从别名可以看出此模式将对象组合成树状结构，让用户能以相同的方式使用单独对象和组合对象。")]),t._v(" "),r("h2",{attrs:{id:"_2-意图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-意图"}},[t._v("#")]),t._v(" 2.意图")]),t._v(" "),r("p",[t._v("用一个共同的接口描述小的组件和大的组合对象所有的共同操作，大的组合对象通过将工作委派给子元素，自己只处理中间结果，保证整体和个体的操作统一。也让调用方省去了逐个遍历小组件进行操作。")]),t._v(" "),r("h2",{attrs:{id:"_3-类图示例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-类图示例"}},[t._v("#")]),t._v(" 3.类图示例")]),t._v(" "),r("p",[r("img",{attrs:{src:s(365),alt:"composite"}})]),t._v(" "),r("h2",{attrs:{id:"_4-适用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-适用场景"}},[t._v("#")]),t._v(" 4.适用场景")]),t._v(" "),r("h3",{attrs:{id:"_4-1-实际业务场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-实际业务场景"}},[t._v("#")]),t._v(" 4.1 实际业务场景")]),t._v(" "),r("ul",[r("li",[t._v("如果需要描述一组复杂的嵌套树状结构对象，可以使用组合模式")]),t._v(" "),r("li",[t._v("如果对象的组合和单个子组件行为相同，而调用方又可以同时调用子组件和复杂对象，那也可以使用组合模式。\n"),r("ul",[r("li",[t._v("组合计费，一个大的收费项目由多个单独的收费项和小的收费项目组合，每种收费组合还有自己的计算方式，可以采用组合模式，")])])])]),t._v(" "),r("h3",{attrs:{id:"_4-2-开源实例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-开源实例"}},[t._v("#")]),t._v(" 4.2 开源实例")]),t._v(" "),r("ul",[r("li",[t._v("java.util.List#addAll(Collection)")])]),t._v(" "),r("h2",{attrs:{id:"_5-实现细节和技巧"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-实现细节和技巧"}},[t._v("#")]),t._v(" 5.实现细节和技巧")])])}),[],!1,null,null,null);a.default=_.exports}}]);