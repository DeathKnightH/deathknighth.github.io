(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{399:function(s,a,e){"use strict";e.r(a);var t=e(44),n=Object(t.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"lfu-算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lfu-算法"}},[s._v("#")]),s._v(" LFU 算法")]),s._v(" "),e("h2",{attrs:{id:"_0-概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_0-概念"}},[s._v("#")]),s._v(" 0. 概念")]),s._v(" "),e("p",[s._v("LFU(Least Frequently Used)算法，也是一种常用的缓存淘汰算法，意为淘汰"),e("code",[s._v("使用次数最少")]),s._v("的部分，如果使用次数相同，则淘汰其中"),e("code",[s._v("最近最少使用")]),s._v("的部分。")]),s._v(" "),e("p",[s._v("可见 LFU 是在 LRU 的基础上增加了使用次数的比较。")]),s._v(" "),e("h2",{attrs:{id:"_1-算法描述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-算法描述"}},[s._v("#")]),s._v(" 1. 算法描述")]),s._v(" "),e("p",[s._v("算法对外暴露的接口与 LRU 算法相似：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("class LFUCache {\n    // 构造时传入 cache 容量\n    public LFUCache(int capacity) {\n\n    }\n    \n    // 随机取，如果 key 在  cache 中不存在则返回 -1\n    public int get(int key) {\n\n    }\n    \n    // 存入 key-value，如果 key 在 cache 中存在则更新对应的 value，否则新增。新增时保证元素总量不超过容量\n    public void put(int key, int value) {\n\n    }\n}\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br")])]),e("h2",{attrs:{id:"_2-算法设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-算法设计"}},[s._v("#")]),s._v(" 2. 算法设计")]),s._v(" "),e("p",[s._v("看上去只是比 LRU 多了一个使用次数的比较，但是需要考虑的问题多了不少：")]),s._v(" "),e("p",[s._v("1、每次都要从最少使用次数开始删除，因此需要维护一个当前 cache 内最少使用次数的计数器。")]),s._v(" "),e("p",[s._v("2、访问/更新元素都会增加对应 key 的访问次数，要能快速地获取、更新使用次数，因此需要一个 Hash 表存储 key 和 使用次数的映射。")]),s._v(" "),e("p",[s._v("3、需要能通过最少使用次数的值找到对应 key，而且可能找到的是一系列使用次数相同的 key，这些 key 要按使用次序排列，方便二次过滤，因此需要为相同使用次数的 key 维护一个按使用时序排列的的双向链表。")]),s._v(" "),e("p",[s._v("4、当然对于最基本的 get/set 功能，还需要维护一个 hash 表用于存储 key-value。")])])}),[],!1,null,null,null);a.default=n.exports}}]);