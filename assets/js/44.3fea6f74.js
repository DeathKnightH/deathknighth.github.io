(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{414:function(t,s,e){"use strict";e.r(s);var a=e(44),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"二分查找"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二分查找"}},[t._v("#")]),t._v(" 二分查找")]),t._v(" "),e("h2",{attrs:{id:"_1-二分查找基本思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-二分查找基本思路"}},[t._v("#")]),t._v(" 1. 二分查找基本思路")]),t._v(" "),e("p",[t._v("二分查找需要以一个有序的集合为前提。以下均以升序排列为例。")]),t._v(" "),e("p",[t._v("代码框架，以在 "),e("code",[t._v("int")]),t._v(" 数组中查询为例：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int binarySearch(int[] nums, int target){\n  int left = 0;\n  int right = nums.length - 1;\n  while(left <= right){\n    int mid = left + (right - left) / 2;\n    int current = nums[mid];\n    if(current == target){\n      找到target，返回；或者继续查找\n    }else if(current < target){\n      重置 left\n    }else if(current > target){\n      重置 right\n    }\n  }\n  return 结果或者异常;\n}\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br")])]),e("h2",{attrs:{id:"_2-实现细节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现细节"}},[t._v("#")]),t._v(" 2. 实现细节")]),t._v(" "),e("h3",{attrs:{id:"_2-1-搜索确定的一个-target"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-搜索确定的一个-target"}},[t._v("#")]),t._v(" 2.1 搜索确定的一个 target")]),t._v(" "),e("h4",{attrs:{id:"_2-1-1-思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-思路"}},[t._v("#")]),t._v(" 2.1.1 思路")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int binarySearch(int[] nums, int target){\n  int left = 0;\n  int right = nums.length - 1;\n  while(left <= right){\n    int mid = left + (right - left) / 2;\n    int current = nums[mid];\n    if(current == target){\n      return mid;\n    }else if(current < target){\n      left = mid + 1;\n    }else if(current > target){\n      right = mid - 1;\n    }\n  }\n  return -1;\n}\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br")])]),e("p",[t._v("需要注意3个细节：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("while 的退出条件")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("left < right")]),t._v(" 表示退出条件为")])]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("left == right:\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("此时最终形成区间为"),e("code",[t._v("[right, right]")]),t._v("，"),e("code",[t._v("right")]),t._v(" 本身还没有检查过，这样需要单独判断 "),e("code",[t._v("right")]),t._v(" 的值。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("left < right")]),t._v(" 表示退出条件为")])]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("left = right + 1;\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("此时最终形成区间为 "),e("code",[t._v("[right + 1, right]")]),t._v("，这样所有的区间都已经计算过了，不需要额外判断。")])]),t._v(" "),e("li",[e("p",[t._v("当 target 不在搜索区间时下一个区间的变化")]),t._v(" "),e("ul",[e("li",[t._v("target < current")])]),t._v(" "),e("p",[t._v("当前区间中 mid 本身和其右侧的值均大于 target值，所以 mid 本身和其右侧的均可以抛弃，将下次循环的 "),e("code",[t._v("right")]),t._v(" 设置为 "),e("code",[t._v("mid - 1")]),t._v("。")]),t._v(" "),e("ul",[e("li",[t._v("target > current")])]),t._v(" "),e("p",[t._v("当前区间中 mid 本身和其左侧的值均小于 target 值，所以 mid 本身和其左侧的可以抛弃，将下次循环的 "),e("code",[t._v("left")]),t._v(" 设置为 "),e("code",[t._v("mid + 1")]),t._v("。")])]),t._v(" "),e("li",[e("p",[t._v("当 "),e("code",[t._v("target == mid")]),t._v(" 时下一个区间的变化")]),t._v(" "),e("p",[t._v("因为只需要得到一个确定的 target 的位置，当 "),e("code",[t._v("target == mid")]),t._v(" 时说明已经找到一个 target 的位置，可以直接返回了。")])])]),t._v(" "),e("h4",{attrs:{id:"_2-1-2-习题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-习题"}},[t._v("#")]),t._v(" 2.1.2 习题")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/binary-search/",target:"_blank",rel:"noopener noreferrer"}},[t._v("704. 二分查找"),e("OutboundLink")],1)])]),t._v(" "),e("h3",{attrs:{id:"_2-2-搜索一个-target-的左-右边界"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-搜索一个-target-的左-右边界"}},[t._v("#")]),t._v(" 2.2 搜索一个 target 的左/右边界")]),t._v(" "),e("p",[t._v("如果一个集合/数组中的元素有重复的，那么可能会找到多个 target，这时候需要确定多个 target 左/右边界的位置。")]),t._v(" "),e("h4",{attrs:{id:"_2-2-1-思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-思路"}},[t._v("#")]),t._v(" 2.2.1 思路")]),t._v(" "),e("p",[t._v("以左边界为例，")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int binarySearch(int[] nums, int target){\n  int left = 0;\n  int right = nums.length - 1;\n  while(left <= right){\n    int mid = left + (right - left) / 2;\n    int current = nums[mid];\n    if(current == target){\n      right = mid - 1;            // 重点是这里，确保 right + 1 处的值是 target\n    }else if(current < target){\n      left = mid + 1;\n    }else if(current > target){\n      right = mid - 1;\n    }\n  }\n  if(left >= nums.length || nums[left] != target){    // 如果 right + 1 越界或者所在位置的值不是 target，说明 target 不在数组中\n    return -1;\n  }\n  return left;\n}\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br"),e("span",{staticClass:"line-number"},[t._v("18")]),e("br"),e("span",{staticClass:"line-number"},[t._v("19")]),e("br")])]),e("p",[t._v("与无重复元素的查找区别在于遇到 "),e("code",[t._v("current == target")]),t._v(" 的情况，不会马上返回，而是以此确定下次查找的边界：")]),t._v(" "),e("ul",[e("li",[t._v("结果要查 target 的左边界，那么就使 "),e("code",[t._v("right = mid - 1")]),t._v("，保证 right + 1 为要找的左边界。")]),t._v(" "),e("li",[t._v("结果要查 target 的右边界，那么就使 "),e("code",[t._v("left = mid + 1")]),t._v("，保证 left - 1 为要找的右边界。")])]),t._v(" "),e("h4",{attrs:{id:"_2-2-2-习题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-习题"}},[t._v("#")]),t._v(" 2.2.2 习题")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/",target:"_blank",rel:"noopener noreferrer"}},[t._v("34. 在排序数组中查找元素的第一个和最后一个位置"),e("OutboundLink")],1)])]),t._v(" "),e("h3",{attrs:{id:"_2-3-搜索一个最接近-target-的值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-搜索一个最接近-target-的值"}},[t._v("#")]),t._v(" 2.3 搜索一个最接近 target 的值")]),t._v(" "),e("h4",{attrs:{id:"_2-3-1-思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-思路"}},[t._v("#")]),t._v(" 2.3.1 思路")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int binarySearch(int[] nums, int target){\n  int left = 0;\n  int right = nums.length - 1;\n  while(left <= right){\n    int mid = left + (right - left) / 2;\n    int current = nums[mid];\n    if(current == target){\n      return mid;                 // 相等当然差值最小，可以直接返回\n    }else if(current < target){\n      left = mid + 1;\n    }else if(current > target){\n      right = mid - 1;\n    }\n  }\n  \n  if(right == -1){\n    return left;\n  }\n  \n  if(left == nums.length){\n    return right;\n  }\n  \n  return Math.abs(nums[right] - target) > Math.abs(nums[left] - target) ? left : right;\n}\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br"),e("span",{staticClass:"line-number"},[t._v("18")]),e("br"),e("span",{staticClass:"line-number"},[t._v("19")]),e("br"),e("span",{staticClass:"line-number"},[t._v("20")]),e("br"),e("span",{staticClass:"line-number"},[t._v("21")]),e("br"),e("span",{staticClass:"line-number"},[t._v("22")]),e("br"),e("span",{staticClass:"line-number"},[t._v("23")]),e("br"),e("span",{staticClass:"line-number"},[t._v("24")]),e("br"),e("span",{staticClass:"line-number"},[t._v("25")]),e("br")])]),e("p",[t._v("区别在于最后的判断，因为 target 不在数组中时不能直接返回，需要判断哪个位置的值最接近，而又因为循环退出条件为：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("left = right + 1;\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("所以：")]),t._v(" "),e("ul",[e("li",[t._v("当 right 越界时， left 即为最接近的值；")]),t._v(" "),e("li",[t._v("反之当 left 越界时，right 即为最接近的值；")]),t._v(" "),e("li",[t._v("都没越界需要比较 left 和 right 处的值得出最接近的值。")])]),t._v(" "),e("h4",{attrs:{id:"_2-3-2-习题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-习题"}},[t._v("#")]),t._v(" 2.3.2 习题")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/minimum-absolute-sum-difference/",target:"_blank",rel:"noopener noreferrer"}},[t._v("1818. 绝对差值和"),e("OutboundLink")],1)])]),t._v(" "),e("h2",{attrs:{id:"_3-小技巧"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-小技巧"}},[t._v("#")]),t._v(" 3.小技巧")]),t._v(" "),e("h3",{attrs:{id:"_3-1-防止数值溢出"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-防止数值溢出"}},[t._v("#")]),t._v(" 3.1 防止数值溢出")]),t._v(" "),e("p",[t._v("在计算 mid 时使用：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("mid = left + (right - left) / 2; // 实际值还是 (left + right) / 2\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("可以防止 "),e("code",[t._v("left + right")]),t._v(" 值过大，超过变量可表示的范围，带来不可预知的结果。")]),t._v(" "),e("h3",{attrs:{id:"_3-2-多用-else-if-帮助理清思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-多用-else-if-帮助理清思路"}},[t._v("#")]),t._v(" 3.2 多用 else if 帮助理清思路")]),t._v(" "),e("p",[t._v("在每次循环中分块时，如果思路还不够清晰，建议只使用 "),e("code",[t._v("if")]),t._v(" 和 "),e("code",[t._v("else if")]),t._v(" 列举所有情况，不用 "),e("code",[t._v("else")]),t._v(" 语句简化。")]),t._v(" "),e("p",[t._v("等到完全理清思路再用 "),e("code",[t._v("else")]),t._v(" 进行简化。")])])}),[],!1,null,null,null);s.default=n.exports}}]);