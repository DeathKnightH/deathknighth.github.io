(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{383:function(_,v,a){"use strict";a.r(v);var t=a(44),l=Object(t.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h1",{attrs:{id:"数据库系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库系统"}},[_._v("#")]),_._v(" 数据库系统")]),_._v(" "),a("h2",{attrs:{id:"_1-数据库组成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据库组成"}},[_._v("#")]),_._v(" 1. 数据库组成")]),_._v(" "),a("p",[_._v("一个完整的关系数据库大致由以下5个部分组成：")]),_._v(" "),a("ul",[a("li",[_._v("存储管理器（transactional storage manager）")])]),_._v(" "),a("p",[_._v("管理具体数据的存储、索引等，通常采用 B+ 树存储。")]),_._v(" "),a("ul",[a("li",[_._v("关系查询处理器（relational query processer）")])]),_._v(" "),a("p",[_._v("解析/优化/鉴权 SQL 查询。")]),_._v(" "),a("ul",[a("li",[_._v("客户端/服务端通信管理器（client communications manager）")])]),_._v(" "),a("p",[_._v("管理客户端和数据库的交互，处理客户端请求。")]),_._v(" "),a("ul",[a("li",[_._v("进程管理器（process manager）")])]),_._v(" "),a("p",[_._v("负责管理和分配计算资源。")]),_._v(" "),a("ul",[a("li",[_._v("共享组件和工具（shared components and utilities）")])]),_._v(" "),a("p",[_._v("一些在所有商用 DBMS 中都有的共享组件和工具，例如备份、监控、统计工具。")]),_._v(" "),a("p",[_._v("由于一个数据库系统涉及的模块太多，这里只记录比较重要的模块。")]),_._v(" "),a("h3",{attrs:{id:"_1-1-客户端管理器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-客户端管理器"}},[_._v("#")]),_._v(" 1.1 客户端管理器")]),_._v(" "),a("p",[_._v("用于处理客户端通信。")]),_._v(" "),a("p",[_._v("客户端通过客户端管理器访问数据库，此时通常客户端管理器有以下作用：")]),_._v(" "),a("ul",[a("li",[_._v("调用权限管理验证客户端权限")]),_._v(" "),a("li",[_._v("管理客户端连接")]),_._v(" "),a("li",[_._v("接收 SQL 请求，并交给 SQL 引擎处理")]),_._v(" "),a("li",[_._v("将获取的结果集返回给客户端")])]),_._v(" "),a("h3",{attrs:{id:"_1-2-关系查询处理器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-关系查询处理器"}},[_._v("#")]),_._v(" 1.2 关系查询处理器")]),_._v(" "),a("p",[_._v("一条 SQL 语句进入引擎会经过 "),a("code",[_._v("解析")]),_._v("、"),a("code",[_._v("重写")]),_._v("、"),a("code",[_._v("优化")]),_._v("、"),a("code",[_._v("编译")]),_._v("，最后才会执行。")]),_._v(" "),a("ul",[a("li",[_._v("解析")])]),_._v(" "),a("p",[_._v("输入的是原始的 SQL 语句，输出的是解析后的内部表示（通常是一个树型结构）。")]),_._v(" "),a("p",[_._v("解析过程会进行一系列的检查：")]),_._v(" "),a("ul",[a("li",[_._v("关键字是否正确")]),_._v(" "),a("li",[_._v("语法是否正确")]),_._v(" "),a("li",[_._v("数据库表、字段是否存在")]),_._v(" "),a("li",[_._v("运算类型是否正确")]),_._v(" "),a("li",[_._v("是否有权限读取/写入数据")])]),_._v(" "),a("ul",[a("li",[_._v("重写")])]),_._v(" "),a("p",[_._v("重写会进行一些预优化：")]),_._v(" "),a("ul",[a("li",[_._v("视图合并，将视图转换为对应的 SQL 查询。")]),_._v(" "),a("li",[_._v("删除冗余的Join。")]),_._v(" "),a("li",[_._v("子查询扁平化，尝试移除子查询，合并到主查询中。")]),_._v(" "),a("li",[_._v("计算常数并赋值。")])]),_._v(" "),a("ul",[a("li",[_._v("优化")])]),_._v(" "),a("p",[_._v("通常使用的是基于成本的优化（CBO）。\n最终生成一个相对较优的查询计划。")]),_._v(" "),a("ul",[a("li",[_._v("编译")])]),_._v(" "),a("p",[_._v("将查询计划编译为可执行的代码。")]),_._v(" "),a("ul",[a("li",[_._v("执行")])]),_._v(" "),a("p",[_._v("执行代码，与数据管理器交互，获取/写入数据。")]),_._v(" "),a("h3",{attrs:{id:"_1-3-存储管理器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-存储管理器"}},[_._v("#")]),_._v(" 1.3 存储管理器")]),_._v(" "),a("h4",{attrs:{id:"_1-3-1-缓存管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-1-缓存管理"}},[_._v("#")]),_._v(" 1.3.1 缓存管理")]),_._v(" "),a("ul",[a("li",[_._v("缓存读")])]),_._v(" "),a("p",[_._v("预读取，根据上一步的查询计划和统计监控可以预测查询需要磁盘上的哪些数据，在查询计算时就可以对磁盘中的数据进行预读取，读取到缓冲区中。")]),_._v(" "),a("p",[_._v("由于缓冲区不是无限大的，因此缓冲区中的数据需要经常刷新置换，而如果每次都清空缓冲区代价太大，因此需要有合适缓冲区置换算法来计算过期数据。")]),_._v(" "),a("p",[_._v("由一开始的 LRU 到改进后的 LRU-K。")]),_._v(" "),a("ul",[a("li",[_._v("缓存写")])]),_._v(" "),a("p",[_._v("避免多次进行磁盘写入，所以写入操作也会先记录在缓冲区，再一次性批量刷入磁盘。")])])}),[],!1,null,null,null);v.default=l.exports}}]);