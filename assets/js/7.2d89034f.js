(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{358:function(a,_,t){a.exports=t.p+"assets/img/Classlifecycle.drawio.28a78d45.png"},359:function(a,_,t){a.exports=t.p+"assets/img/Classloadprocess.drawio.dd29d369.png"},427:function(a,_,t){"use strict";t.r(_);var v=t(44),s=Object(v.a)({},(function(){var a=this,_=a.$createElement,v=a._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"类加载机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类加载机制"}},[a._v("#")]),a._v(" 类加载机制")]),a._v(" "),v("h2",{attrs:{id:"_1-概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[a._v("#")]),a._v(" 1. 概述")]),a._v(" "),v("p",[a._v("区别于其他在编译时需要进行连接工作的语言，Java 的类型加载、连接、初始化过程都是在运行时完成的。")]),a._v(" "),v("p",[a._v("虚拟机把描述类的数据从 class 文件（不一定是磁盘文件，只要是能输入的二进制流都行）加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是类加载。")]),a._v(" "),v("p",[a._v("在虚拟机中类的生命周期如下：\n"),v("img",{attrs:{src:t(358),alt:"image-class-lifecycle"}})]),a._v(" "),v("p",[a._v("这些阶段除了 "),v("code",[a._v("解析")]),a._v(" 以外都是按顺序开始的，但不一定按顺序完成，比如可能类还没完成 "),v("code",[a._v("加载")]),a._v("，就已经开始 "),v("code",[a._v("验证")]),a._v(" 了，这些阶段通常是互相交叉进行的。")]),a._v(" "),v("h2",{attrs:{id:"_2-类加载的时机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-类加载的时机"}},[a._v("#")]),a._v(" 2. 类加载的时机")]),a._v(" "),v("p",[a._v("虚拟机规范没有规定 "),v("code",[a._v("Loading")]),a._v(" 阶段执行的时机，但是强制规定了 "),v("code",[a._v("Initialization")]),a._v(" 阶段的执行时机，即有且仅有在 6 种主动引用类的情况下，必须进行 "),v("code",[a._v("Initialization")]),a._v("。")]),a._v(" "),v("p",[a._v("可以使用：")]),a._v(" "),v("blockquote",[v("p",[a._v("-XX:+TraceClassLoading")])]),a._v(" "),v("p",[a._v("参数来观察类加载的实际情况。也可以通过在类的静态域添加 print 方法来判断该类是否执行了初始化。")]),a._v(" "),v("h3",{attrs:{id:"_2-1-主动引用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-主动引用"}},[a._v("#")]),a._v(" 2.1 主动引用")]),a._v(" "),v("p",[a._v("主动引用在规范中有且仅有 6 种情况：")]),a._v(" "),v("ul",[v("li",[a._v("遇到 new、getstatic、putstatic、invokestatic 这 4 条字节码指令的任意一条时，如果目标类没有进行初始化，则会先触发初始化。")]),a._v(" "),v("li",[a._v("使用 java.lang.reflect 包的方法对目标类进行反射调用时，如果目标类没有进行初始化，则会先触发初始化。")]),a._v(" "),v("li",[a._v("进行一个类的初始化时，如果该类的父类没有进行初始化，则会先触发其父类的初始化。")]),a._v(" "),v("li",[a._v("虚拟机启动时，用户指定执行的主类（即 main 方法所在的类）会先触发初始化。")]),a._v(" "),v("li",[a._v("使用动态语言支持时，MethodHandle 和 VarHandle 调用前需要使用 "),v("code",[a._v("findeStaticVarHandle")]),a._v(" 来初始化目标类。")]),a._v(" "),v("li",[a._v("JDK 8 之后如果在接口中定义了 default 方法，在其实现类初始化之前需要先对接口进行初始化。")])]),a._v(" "),v("h3",{attrs:{id:"_2-2-被动引用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-被动引用"}},[a._v("#")]),a._v(" 2.2 被动引用")]),a._v(" "),v("p",[a._v("除了以上 6 种强制初始化的情况，其余情况都是被动引用，不用强制执行初始化。")]),a._v(" "),v("h2",{attrs:{id:"_3-类加载过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-类加载过程"}},[a._v("#")]),a._v(" 3. 类加载过程")]),a._v(" "),v("p",[a._v("类加载总体分为 5 个阶段，加载、验证、准备、解析、初始化。其中验证、准备、解析可以统称为 "),v("code",[a._v("连接")]),a._v("。\n"),v("img",{attrs:{src:t(359),alt:"image-class-lifecycle"}})]),a._v(" "),v("h3",{attrs:{id:"_3-1-加载-loading"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-加载-loading"}},[a._v("#")]),a._v(" 3.1 加载（Loading）")]),a._v(" "),v("p",[a._v("加载阶段是类加载过程的第一步，主要完成以下 3 件事：")]),a._v(" "),v("ol",[v("li",[a._v("通过类的全限定名来获取此类的二进制字节流。")]),a._v(" "),v("li",[a._v("将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。")]),a._v(" "),v("li",[a._v("在内存中生成一个代表这个类的 "),v("code",[a._v("java.lang.Class")]),a._v(" 对象，作为方法区这些数据的访问入口。")])]),a._v(" "),v("p",[a._v("以上 3 点都没有具体的描述，实际实现方式和应用都很灵活。")]),a._v(" "),v("p",[a._v("利用这些灵活性，我们可以定制加载阶段的具体实现，比如自定义获取二进制流的过程，可以从网络上来，也可以从加密后的文件解密得来，也可以在运行时计算生成。")]),a._v(" "),v("h3",{attrs:{id:"_3-2-验证-verification"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-验证-verification"}},[a._v("#")]),a._v(" 3.2 验证（Verification）")]),a._v(" "),v("p",[a._v("验证阶段的目的是确保 Class 二进制流中包含的信息符合虚拟机的要求，同时保证其内容不会危害虚拟机的安全。")]),a._v(" "),v("p",[a._v("总体上看，此阶段大致会完成以下 4 个校验动作：\n1）文件格式验证\n2）元数据验证\n3）字节码验证\n4）符合引用验证")])])}),[],!1,null,null,null);_.default=s.exports}}]);