(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{503:function(a,e,s){"use strict";s.r(e);var t=s(44),r=Object(t.a)({},(function(){var a=this,e=a.$createElement,s=a._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"集合类改动"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#集合类改动"}},[a._v("#")]),a._v(" 集合类改动")]),a._v(" "),s("h2",{attrs:{id:"_1-stream-api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-stream-api"}},[a._v("#")]),a._v(" 1. stream api")]),a._v(" "),s("p",[a._v("Collection 接口添加了 stream 相关的 api：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("stream();\nparallelStream();\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("p",[a._v("这两个都是 default 方法，默认依赖于 Spliterators 类将 Collection 集合转换为 Spliterator，再转换为 Stream 进行后续流编程。")]),a._v(" "),s("h2",{attrs:{id:"_2-map-新增-api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-map-新增-api"}},[a._v("#")]),a._v(" 2. map 新增 api")]),a._v(" "),s("p",[a._v("都是很实用的 API：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("forEach(BiConsumer);            // 按 entry set 迭代顺序对集合内所有元素执行这个消费者\nputIfAbsent(key, value);        // 如果 map 中没有这个 key 就放入 key 和 value，否则就什么都不做并返回存在的 key 对应的 value\ncomputeIfAbsent(key, Function); // 如果 map 中没有这个 key 或者对应的 value 不符合按照 Function 计算的结果就放入 key 和计算结果作为 value，否则就什么都不做并返回原有的 value（null 也行）\ngetOrDefault(key, defaultValue);// 如果 map 中有这个 key 就返回对应的 value，否则就返回 defaultV\nremove(key, value);             // 如果 key 和 value 都符合才删除元素并返回 true，否则什么都不做并返回 false\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("h2",{attrs:{id:"_3-map-内部实现改进"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-map-内部实现改进"}},[a._v("#")]),a._v(" 3. map 内部实现改进")]),a._v(" "),s("h3",{attrs:{id:"_3-1-hashmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-hashmap"}},[a._v("#")]),a._v(" 3.1 HashMap")]),a._v(" "),s("p",[a._v("Java 7 中 HashMap 可以看做是 "),s("code",[a._v("数组 + 链表")]),a._v(" 的实现，当计算出来两个元素的 hashcode 一样的话，会在数组的相应位置生成链表，把相同 hashcode 的元素接到链表上。")]),a._v(" "),s("p",[a._v("Java 8 中 HashMap 改进为 "),s("code",[a._v("数组 + 链表 + 红黑树")]),a._v(" 的实现，当链表长度达到 8 时会转换为红黑树，降低在同一 hashcode 情况下的查询时间。")]),a._v(" "),s("h3",{attrs:{id:"_3-2-concurrenthashmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-concurrenthashmap"}},[a._v("#")]),a._v(" 3.2 ConcurrentHashMap")]),a._v(" "),s("p",[a._v("Java 7 中 ConcurrentHashMap 采用分段锁机制来降低锁粒度，实现更高效（相比纯粹添加 synchronized 关键字来实现线程安全的 HashTable 或者 Collections.synchronizedMap(Map) 方法更高效）的同步。")]),a._v(" "),s("p",[a._v("Java 8 中 ConcurrentHashMap 改进为 "),s("code",[a._v("数组 + 链表 + 红黑树")]),a._v(" 的实现，同时使用 CAS 机制 + synchronized，计算得到的 hashcode 对应的位置是头结点时使用 synchronized 锁头结点，否则用 CAS 设置值。\n这样没有 hash 冲突时都是无锁操作，大大提升了性能。")])])}),[],!1,null,null,null);e.default=r.exports}}]);